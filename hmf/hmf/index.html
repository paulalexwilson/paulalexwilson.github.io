<!DOCTYPE html>
<html>

<!--
    Editorial notes:
    * Anchors are used for terms only the first time it's used within a section. This is 
      to avoid extensive and noisy hyperlink which might be overburdening for the reader. 

    Todos:
    * Complete terms list 
    * 
-->

<head>
    <meta charset="utf-8" />
    <title>Hierarchical Metadata Framework - Core Model v1.0</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
    <script src="../common/common.js" class="remove" defer></script>
    <script class="remove">
        // All config options at https://respec.org/docs/
        var respecConfig = {
            shortName: "HMF Model",
            specStatus: "base",
            noRecTrack: true,
            editors: [{
                name: "Paul Wilson"
            }, {
                name: "Dave Clark"
            }],
            xref: "web-platform",
            latestVersion: null,
            subtitle: "An abstract model for hierarchical graph metadata",
        };
    </script>
    <style src="../common/style.css" type="text/css"></style>
    <style type="text/css">
        .illustration {
            text-align: center;
        }
    </style>
</head>

<body>
    <p class="copyright">Copyright...</p>
    <section id="abstract">
        <p>
            This specification describes the Hierarchical Metadata Framework (HMF) core model, a standard model and
            framework for hierarchical & linked metadata. HMF addresses many aspects of metadata
            representation including domain modelling, versioning, identity & location, navigation, namespacing,
            reasoning, reification and so on. HMF serves as the foundation for applications dealing with
            the metadata trees and graphs at the heart of modern web and media organisations.
        </p>
        <p>
            HMF is a framework encompassing both the storage and representation of hierarchical metadata as well
            as the semantics of operations over that metadata. This specification therefore must be complimented
            by a concrete document syntax for the serialization of metadata and a repository implementation providing
            the APIs for those operations.
        </p>
        <p>
            HMF takes inspiration from a variety of specifications including [[[JSON-LD11]]], [[[RDF-CONCEPTS]]],
            [[[XML]]] and <a
                href="https://developer.adobe.com/experience-manager/reference-materials/spec/jcr/2.0/index.html">Content
                Repository for Java Technology API Specification (JSR-283)</a>.
        </p>

    </section>
    <section id="sotd" class="override">
        <h2>Status of this Document</h2>
        <p>This document is in Draft state.</p>

    </section>
    <section class="normative">
        <h2>Terminology & Conventions</h2>
        <section>
            <h3>Terminology</h3>
            <div data-include="../common/terms.html" data-oninclude="restrictReferences"></div>
        </section>

        <section class="normative">
            <h3>Diagram Conventions</h3>
            <p>
                This specification uses diagrams consisting of the following elements
                to clarify concepts within the model:
            </p>
            <table class="simple" style="width:100%">
                <thead>
                    <tr>
                        <th>Element</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><img src="node-convention.png" alt="Node" width="110" /></td>
                        <td>Illustrates a regular <a>node</a>.</td>
                    </tr>
                    <tr>
                        <td><img src="typed-node-convention.png" alt="Node" width="110" /></td>
                        <td>Illustrates a <a>node</a> including its <a>primary type</a> in compact form</td>
                    </tr>
                    <tr>
                        <td><img src="version-convention.png" alt="Node" width="110" /></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><img src="node-type-convention.png" alt="Node" width="110" /></td>
                        <td></td>
                    </tr>
                </tbody>
            </table>
        </section>
    </section>

    <section class="information">
        <h1 id="introduction">Introduction</h1>
        <p>
            <abbr title="Hierarchical Metadata Framework">HMF</abbr> is a
            framework for hierarchical metadata. It provides a foundation for organising, querying, inferencing,
            change-tracking and administering the metadata trees and graphs that lie at the heart of modern
            web and media organisations. <abbr title="Hierarchical Metadata Framework">HMF</abbr> was conceived as
            a foundation for <em>media-content</em> curation and syndication, but was designed to be agnostic
            to any domain where metadata is <em>primarily hierarchical</em>.
        </p>
        <p>
            <abbr title="Hierarchical Metadata Framework">HMF</abbr> allows for information to be captured and
            formalized
            within the model through <a>types</a>. <a>Types</a> categorise, characterise and constrain metadata and
            so serve as building blocks for robust applications. <a>Types</a> can be applied to metadata at <em>any
                point during its lifecycle</em> allowing for raw and unstructured data to be edited and reasoned into
            formalised, semantically rich trees.
        </p>

        <hr />

        <p>
            By focusing on domains where metadata is organised primarily into hierarchies,
            <abbr title="Hierarchical Metadata Framework">HMF</abbr> supports a rich set of semantics that
            would be otherwise unavailable:
            <dl>
                <dt>Move, Copy & Delete</dt>
                <dd>Move, copy & delete operations applied on a <a>node</a> apply to the their entire <a>subtree</a>.
                    This is
                    conceptually identical to copying files and folders on a filesystem and allows metadata to be
                    organised and managed whilst preserving structure.</dd>
                <dt>Child Node Constraints</dt>
                <dd>HMF allows <a>child node type definitions</a> to dictate which child-types are permitted on a
                    <a>node</a>.
                    Using child node constraints, we can build metadata trees with <em>strong guarantees</em> about the
                    validity of both data and structure.
                </dd>
                <dt>Cascading Access Control</dt>
                <dd>Permissions and access control directives can be applied to <a>nodes</a> and to all
                    descendents
                    in a <em>cascading</em> fashion. Much like a filesystem, user or group principals therefore can own
                    and administer entire <a>subtrees</a> without the overhead of permission-management of every node.
                </dd>
                <dt>Tree Versioning</dt>
                <dd>When a specific version of a <a>node</a> is tracked, it is often desirable to also track its
                    subtree.
                    HMF allows subtrees of a <a>versionable</a> <a>node</a> to be automatically tracked when the owning
                    <a>versionable</a> <a>node</a> is checked-in.
                </dd>
                <dt>Location & Navigation</dt>
                <dd><a>Trees</a> give <a>nodes</a> and <a>properties</a> a <em>location</em> as defined by its
                    <a>path</a> relative to the metadata <a>root</a>. This means information not only has
                    <a>identity</a>
                    but also <a>location</a> allowing for metadata to be discovered or accessed relative to other
                    metadata
                    via the process of <a>navigation</a>. <a>Navigation</a> allows knowledge to be <em>explored</em>
                    without prior information about what is available or even the structure of the metadata tree.</dd>

            </dl>
        </p>

        <hr />

        <p>
            <abbr title="Hierarchical Metadata Framework">HMF</abbr> represents metadata as a <em>linked data
                graph</em> (see [[[Linked-Data]]]). All <a>entities</a> including <a>nodes</a> and <a>properties</a>
            represented by an HMF model are unambigiously
            identified using an <a data-link-type="dfn" href="https://tools.ietf.org/html/rfc3987#section-2"><abbr
                    title="Internationalized Resource Identifier">IRI</abbr></a>. Using a universally unique
            resource identifier for all atoms of data allows systems to precisely resolve ownership and
            meaning of knowledge held within HMF. Using IRIs as the foundation identifier along with <a>namespacing</a>
            also allows HMF to represent knowledge describing a common subject but belonging to unrelated systems or
            sources without collision or ambiguity. It also allows modules and components to be registered against
            subsets of metadata (as identified by a <a>namespace IRI</a>) stored within HMF whilst ignoring
            irrelevant subsets.
        </p>

        <hr />

        <p>
            This document provides the <em>abstract</em> model for <abbr
                title="Hierarchical Metadata Framework">HMF</abbr>, defining structure and semantics
            independent of any particular document representation, encoding or concrete syntax. This separation allows
            for concrete vocabularies to be defined external to this document each providing their own model
            representation for metadata interchange and delivery. See [[[#concrete-hdf-syntax]]] for a deeper discussion
            of <a>concrete HMF syntaxes</a>.
        </p>

        <section class="informative">
            <h2 id="key-concepts">Key Concepts and Rationale</h2>
            This section highlights some of the key ideas found in <abbr title="Hierarchical Metadata">HMF</abbr>.
            <section>
                <h3 id="nodes-trees">Hybrid Hierarchical-Graph Model</h3>
                <p>
                    <abbr title="Hierarchical Metadata">HMF</abbr> provides a modelling framework
                    for metadata that fits naturally into a <a>tree</a> of <a>nodes</a>. The <a>tree</a>
                    structure is convenient for organising information in such a way that related
                    metadata can be explored, located, access controled, constrained, versioned,
                    moved or deleted easily.
                </p>

                <p>
                    <a>Trees</a> model sets of <em>one-to-many</em> relationships only. Although fine for some
                    applications it's unlikely to be adequate for non-trivial metadata domains. <abbr
                        title="Hierarchical Metadata">HMF</abbr> therefore allows <a>nodes</a> to reference
                    arbitrary <a>nodes</a> irrespective of whether they share an ancestry. This allows for
                    <em>many-to-many</em> relationships to be modelled within <abbr
                        title="Hierarchical Metadata">HMF</abbr>. The following illustration shows <a>nodes</a>
                    connected by both <a>tree</a> relationships and arbitrary relationships.
                </p>

                <div class="illustration">
                    <p><img src="hybrid-graph-hierarchical.png" alt="Hybrid Graph Hierarchical Model" width="400" /></p>
                    <p class="caption">Hybrid Graph Hierarchical Model</p>
                </div>
                <p class="ednote" title="Illustration needs updating">
                    This illustration needs updating inline with the diagram conventions.
                </p>
                <p>
                    The result is a <i>hybrid-graph</i> model which benefits from first-class <a>tree</a>
                    modelling without limiting which <a>nodes</a> may be related.
                </p>

            </section>

            <section>
                <h3 id="namespaces">Namespaces</h3>

                <p>
                    <a>Namespaces</a> separate data belonging to different domains or arriving from different
                    sources into well-defined, recognisable and distinguishable groupings referenced using an
                    <abbr title="Internationalized Resource Identifier">IRI</abbr>. In <abbr
                        title="Hierarchical Metadata">HMF</abbr> both <a>nodes</a> and <a>properties</a>
                    are namespaced, meaning that structural and value elements of the model exist not only
                    within the <a>tree</a> but also within a <a>namespace</a>.
                </p>
                <div class="illustration">
                    <p><img src="namespaces.png" alt="Nodes and Properties Occupying Namespaces" width="600" /></p>
                    <p class="caption">Nodes and Properties Occupying Namespaces (<code>ns1</code> & <code>ns2</code>)
                    </p>
                </div>
                <p>
                    <a>Namespaces</a> allow for <a>items</a> to be unambigiously identified within the model,
                    leading to the following benefits:
                    <ul>
                        <li>Nodes and properties arriving from independent sources may coexist within a
                            <a>tree</a> without threat of naming collisions.
                        </li>
                        <li>
                            Metadata consumers may use the namespace to understand additional type information
                            about <a>items</a> in the <a>tree</a> and may even use the namespace to resolve
                            further type information about that data.
                        </li>
                        <li>
                            Consumers only interested in a subset of namespaces may mask away values or even
                            entire sub-trees that are not relevant to their needs.
                        </li>
                        <li>
                            User interface components may represent data belonging to an individual namespace in unique
                            and distinct ways
                        </li>
                        <li>
                            Plugin components within software systems built atop HMF may be registered and
                            activated when data belonging to a specific namespace is present.
                        </li>
                    </ul>
                </p>

            </section>

            <section>
                <h2>Types & Domain Modelling</h2>
                <p>
                    <a>Types</a> in <abbr title="Hierarchical Metadata Framework">HMF</abbr> provide the means
                    to <em>represent knowledge</em> within the sytem through <a>formalisms</a> about a given domain
                    within the metadata model. HMF is unique in that types are themselves <em>first-class
                        metadata</em> within the model. Types may be dynamically applied and modified without
                    compromising the integrity of the metadata <a>trees</a> they formalise.
                </p>
                <p>
                    The dynamic nature of types makes HMF ideally suited to applications where metadata is
                    modified and matured within the system until it is ready for export or delivery. Metadata
                    may arrive in a raw and unstructured form and have types progressively applied
                    until meeting the preconditions for a downstream system. HMF allows
                    a <a>node</a> or <a>tree</a> to be evaluated in terms of types, and then for that type
                    to be applied.
                </p>
                <p>
                    Types categorise and constrain both values (i.e. held within <a>properties</a>) as well as
                    the hierarchical structure of a <a>tree</a>. By enforcing that a <a>node</a> and its descendents
                    have specific <a>node</a> types, HMF can make <em>strong guarantees</em> about what clients
                    can expect as they traverse and <a>tree</a> hierarchy and its data.
                </p>
            </section>
            <section>
                <h2 id="versioning-intro">Versioning</h2>

                <p>
                    HMF&quot;s versioning capability allows the state of a <a>node</a> and its subtree to be
                    recorded and later accessed, restored or referenced. Versioning is key for editorial scenarios
                    where metadata changes may need to be reverted, or a record of modifications is needed for
                    auditing purposes. Also the ability have a <a>node</a> hold a <a>reference</a> to a version
                    of another <a>node</a> means it can guarantee the state of the referenced node and its immutability.
                </p>
                <div class="illustration">
                    <p><img src="versioning-introduction.png" alt="Node Versioning & Version Storage" width="600" /></p>
                    <p class="caption">A <a>node</a> with versions (<code>v1,v2,v3</code>) available in <a>version
                            storage</a>
                    </p>
                </div>
                <p>
                    Versions in HMF provide a snapshot of the state of a <a>node</a> and its <a>versionable subtree</a>
                    in much the same way that a version control system holds the historical state of the filesystem.
                    In HMF, version histories are linear changesets and the standard model does not provide the means
                    to branch and merge version histories in the same way that modern version control systems can. That
                    is, versioning in HMF is a means to track historical state; it is not the basis for a branch-based
                    editorial workflow.
                </p>

            </section>
            <section>
                <h2 id="annotations-intro">Annotations</h2>

                <p>
                    <a>Annotations</a> address the problem of how to capture additional information about
                    the <a>properties</a> and <a>relationships</a> of a <a>node</a>. For example, a
                    <a>node</a> may contain a <a>property</a> named <code>title</code> with a value,
                    however we may want to record additional information such as certainty scores, weights,
                    temporal restrictions, permissions and provenance information. Annotations solve
                    this by providing <a>properties</a> <em>about <a>properties</a> or <a>relationships</a></em>.
                </p>
                <p>
                    The following illustration show an annotation property capturing additional information
                    about the <code>title</code> <a>property</a>, specifically the timestamp of when the data was
                    <code>provided</code>.
                    We might also choose to store which data source provided this property or when the
                    information is due to expire or need reviewing:
                </p>

                <div class="illustration">
                    <p><img src="annotation-example.png" alt="Property Annotation" width="600" /></p>
                    <p class="caption">Annotation of a Property</p>
                </div>

                <p>
                    An annotation can also be applied to a <a>relationship</a> to capture additional
                    information about the relation, such as the expected type of the referred <a>node</a>.
                    An annotation may contain a reference to another <a>node</a> offering a way to
                    indirectly link <a>nodes</a> to both <a>properties</a>and child <a>relationships</a>.
                    Annotations are versioned along with the <a>node</a> so that the annotated state is
                    captured alongside checked-in node state.
                </p>

                <p>
                    Annotations are a simple but powerful feature of HMF. They can be used to capture
                    elaborate multi-dimensional structures around the core metadata domain.
                </p>

            </section>
        </section>
    </section>
    <section>
        <h2 id="representation">Tree Primitives</h2>
        <section class="informative">
            <h3>Introduction</h3>
            <p>
                Core to the HMF standard model is the concept of a <a>tree</a> consisting of a graph
                of <a>items</a>. The term <a>item</a> refers to both <a>nodes</a> and <a>properties</a>
                which together provide the primitives for representing the <em>values</em> and <em>structure</em>
                of metadata. All <a>items</a> are said to have a <a>location</a> which can be represented
                using a <a>path</a> (see [[[#paths]]]).
            </p>
            <p>
                This section describes how HMF uses <a>items</a> to store and organise metadata.
            </p>
        </section>


        <section>
            <h3 id="entities">Entities</h3>
            <p>
                The term <a>entity</a> refers to anything in the repository that may have an <a>identity</a>
                (as expressed as an IRI) and/or <a>location</a> and may be represented using some vocabulary.
                <dl>
                    <dt>nodes</dt>
                    <dd>All <a>nodes</a> have an identity and location. See [[[#nodes]]].</dd>
                    <dt>properties</dt>
                    <dd><a>Properties</a> do not have an identity however they do have a <a>location</a></dd>
                    <dt>schemas</dt>
                    <dd>Implemented as a special type of <a>node</a>, they have an identity and can be represented</dd>
                    <dt>namespace registry</dt>
                    <dd>Provides the mapping </dd>
                    <dt>repository</dt>
                    <dd>The repository should be identifiable or otherwise resolveable and the repository
                        configuration should be
                    </dd>
                </dl>
            </p>
            <p class="ednote" title="This section is weak">
                Consider refining or removing this section. Could we identify an entry-point resource?
            </p>
            <section>
                <h4>Aggregates</h4>
                <p>
                    HMF encourages the normalization of a domain model into trees. Typically, APIs and clients
                    deal with trees rather than individual nodes and properties.
                </p>
                <p>
                    An aggregate refers to a node and its versionable subtree.
                </p>

            </section>
        </section>

        <section>
            <h3 id="nodes">Nodes</h3>
            <section class="informative">
                <h4>Introduction</h4>
                <p>
                    <a>Nodes</a> represent <a>entities</a> and provide the <i>structure</i> to data within the <abbr
                        title="Hierarchical Metadata Framework">HMF</abbr> model. They provide
                    identity and type, as well as relationships to other <a>nodes</a>. It is through <a>nodes</a> that
                    content hierarchies are formed, with one <a>node</a> able to act as a <i>parent</i> or
                    <i>container</i> for another <a>node</a>.
                </p>
                <div class="illustration">
                    <p><img src="hmf-nodes.png" alt="Nodes" width="400" /></p>
                    <p class="caption">Nodes with parent and child relationships</p>
                </div>
                <p>
                    Nodes have <a>names</a> (see [[[#names]]]) which identify them among their siblings and are used
                    as <a>segments</a> in <a>paths</a> (see [[[#path-segments]]]). Nodes also have a universally
                    unique <a>identity</a> encoded as an IRI (see [[[#node-identity]]]) allowing a node to be resolved
                    independently of its location.
                </p>
                <p>
                    <a>Nodes</a> have a single <i>parent</i> relationship to their <i>parent</i> <a>node</a> (except
                    for the <a>root node</a>, see [[[#root-node]]]), and zero-or-more <i>child</i> <a>nodes</a>.
                    These parent-child relationships form an acyclic graph (formally referred to as a <a>tree</a>)
                    holding the primary structure of the metadata. All <a>nodes</a> are connected to all other nodes
                    via parent-child relationships, if only via the <a>root node</a>.
                </p>
                <p>
                    <a>Nodes</a> may be <em>copied</em>, <em>moved</em> and <em>deleted</em>. These operations affect
                    each of their ancester <a>nodes</a> to.
                </p>
                <p>
                    A <i>child</i> is affected by its parent and ancestors in various ways. For example, <i>copy</i> and
                    <i>move</i> operations on a <a>node</a> will recursively copy the <a>node</a>'s descendents (see
                    [[[#move-copy-delete]]]). Permissions applied within a <a>repository</a> to a parent will
                    <i>cascade</i> to descendents. The versioning strategy applied to a <a>node</a> will govern the
                    <i>read-only</i> status of a child when the parent is checked-in (see [[[#versioning]]]).
                </p>
                <p>
                    <a>Nodes</a> also act as a container for <a>properties</a> as described in [[[#properties]]].
                    All <a>nodes</a> carry a small set of mandatory properties (see [[[#mandatory-properties]]]).
                </p>
                <p>
                    <a>Nodes</a> have a <a>type</a> (see [[[#node-types]]]) which defines the core characteristics
                    of the node. Nodes have a single <a>primary type</a> and zero or more <a>mixin types</a> which
                    together define what properties and child nodes are required or permitted on the name, and their
                    respective types. Nodes have an <em>is-a</em> relationship with each of its types.
                </p>
                <p>
                    One interesting characteristic of node types is that they can declare child nodes and
                    properties to be <em>auto-created</em>. That is, if no value is supplied during creation,
                    the system will create the property or child node with default values. This is useful to
                    eleviate the user from having to pre-create all mandatory child-nodes explicitly when the
                    parent node is created. It can also provide users with example sub-trees ready for modification.
                </p>
            </section>

            <section>
                <h3 id="node-names">Node Names</h3>
                <p>
                    Each <a>node</a> has a <a>name</a> used to locate the <a>node</a> among its siblings. The
                    <a>node</a> <a>name</a> is used within <a>paths</a> to allow <a>nodes</a> to be located without
                    knowing their <a>identity</a>. See [[[#names]]] for a full description of <a>names</a>.
                </p>
            </section>

            <section>
                <h3 id="node-identity">Node Identity</h3>
                <p>
                    Relying on a <a>path</a> to locate a <a>node</a> could be problematic when we consider that
                    <a>nodes</a> can be moved. In cases where a <a>node</a> must be retrievable irrespective of
                    its location in the hierarchy, we may rely instead on <a>node identity</a>.
                </p>
                <p>
                    A <a>node</a> that can be retrieved using its <a>identity</a> is said to be <a>referenceable</a>.
                    Storage systems would typically use an index to quickly locate a <a>referenceable</a>
                    <a>node</a> within a <a>repository</a>. Maintaining such an index incurs a cost in terms of
                    resources
                    and performance as it would need to be stored and maintained within the storage system. It
                    becomes therefore a <i>design choice</i> as to whether a given node should be <a>referenceable</a>.
                </p>
                <p>
                    <a>Nodes</a> can be related to one another via <a>references</a> as described in
                    [[[#references]]].
                    <a>Node</a> <a>identity</a> is used to support <a>references</a> as only <a>nodes</a>
                    that are <a>referenceable</a> can be referred to from a <a>node</a>.
                </p>
                <p>
                    If a given <a>node</a> has the <i>mixin type</i> (see [[[#primary-mixin-types]]]) of
                    <code>mixin:referenceable</code> then the <a>node</a> is <a>referenceable</a>.
                    <a>Referenceable</a> <a>nodes</a> acquire the <a>property</a>
                    <code>lhd:uuid</code> from the <code>mixin:referenceable</code> type which holds a universally
                    unique
                    <a>repository</a>-managed identifier.
                    This identifier may be used outside of a <a>repository</a> to reference the <a>node</a> and
                    acts as the <a>value</a> of <a>reference</a> <a>properties</a> (see [[[#references]]]).
                </p>
            </section>
            <section>
                <h3 id="root-node">Root Node</h3>
                <p>

                </p>
            </section>
            <section>
                <h3 id="mandatory-properties">Mandatory Properties</h3>
                <p>
                    All <a>nodes</a> contain the following mandatory <a>properties</a>:
                    <table class="simple">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>hmf:primaryType</code></td>
                                <td><code>type:string</code></td>
                                <td>The <a>compact IRI</a> of a <a>node</a>'s primary type (see
                                    [[[#primary-mixin-types]]])
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </p>
            </section>
            <section>
                <h3 id="primary-mixin-types">Primary & Mixin Types</h3>
                <p>
                    All <a>nodes</a> have one or more <a>types</a> which enforce restrictions on the required and
                    permitted child nodes and properties (see [[[#types]]]). All
                </p>
            </section>
            <section>
                <h3>Node Size Limitations</h3>
            </section>
        </section>


        <section>
            <h2 id="properties">Properties</h2>
            <p>
                <a>Properties</a> belong to <a>nodes</a> and hold the <i>data</i> or <a>values</a> associated with
                that <a>node</a>. A <a>property</a> consists of a <a>name</a> as defined in [[[#names]]] and zero
                or more <a>values</a> of a specific <a>type</a>.
            </p>
            <p>
                The <a>type</a> of a <a>property</a> determines the range of <a>values</a> it can store and is defined
                by
                a <a>datatype IRI</a>.
            </p>
            <section>
                <h3 id="mult-value-properties">Multi-value Properties</h3>
                <p>
                    Properties can either be <em>single-valued</em> or <em>multi-valued</em>.
                </p>
                <p>
                    A single-value property, if it exists, must have a value. There is no such thing as a <em>null</em>
                    value. A multi-value property can have zero or more values. Again there is no such thing as a null
                    value, however a multi-value property can be empty, just as an array can be empty.
                </p>
                <p>
                    Whether a particular property is a multi-valued property is governed by the property definition
                    applicable to it, which is determined by the node type of the property's parent node (see
                    [[[#node-types]]]).
                </p>
                <section>
                    <h4 id="property-array-semantics">Array Semantics</h4>
                    <p>
                        The values stored within a multi-valued property are all of the same type. A multi-valued
                        property
                        by default has <em>array</em> semantics. That is, they are <em>ordered</em> and may contain
                        <em>duplicate</em> values.
                    </p>
                </section>
                <section>
                    <h4 id="property-set-semantics">Set Semantics</h4>
                    <p>
                        A multi-value property can be declared to have <em>set</em> semantics. In this case, the
                        property
                        will only every contain unique values and there will be no defined ordering.
                    </p>
                </section>
            </section>
        </section>

        <section>
            <h2 id="working tree">Working Tree</h2>
        </section>

        <section>
            <h2 id="names">Names &amp; Namespaces</h2>
            <p>
                <a>Names</a> in <abbr title="Hierarchical Metadata Framework">HMF</abbr> are conceptually the same as
                <a>names</a> in [[XML]]. They consist of a <a>namespace IRI</a> (or the empty string in the case of
                [[[#empty-namespace]]]) and a <a>local name</a>, and are written in their expanded form as
                <code>{NAMESPACE}LOCAL_NAME</code>, for example:
            </p>
            <p>
                <code>{http://hmf.org/ns/hmf/1.0}primaryType</code>
            </p>
            <p>
                <code>NAMESPACE</code> is either the empty string <code>""</code> or a <a>namespace IRI</a> that
                identifies the <a>namespace</a> and must be <em>registered</em> within the <abbr
                    title="Hierarchical Metadata Framework">HMF</abbr> storage layer before it is used.
            </p>
            <p>
                <a>Namespaces</a> are <em>registered</em> along with a <a>prefix</a> allowing <a>names</a> to be
                written in their <em>compact</em> form; <code>PREFIX:LOCAL_NAME</code>, for example:
            </p>
            <p>
                <code>hmf:primaryType</code>
            </p>
            <p>
                The compact form of a <a>name</a> is commonly used, however a namespace mapping of <a>prefixes</a>
                to <a>namespace IRIs</a> must be supplied.
            </p>
            <p>
                <div class="note">
                    <p>
                        [[XML]] and [[RDF-CONCEPTS]] both use resource identifiers as names but in subtly different
                        ways.
                        In [[XML]] a name is an <em>ordered pair</em> consisting of a <a>namespace IRI</a> and a
                        <a>local
                            name</a>
                        which is commonly written in the form <a>namespace</a>:<a>local name</a>. A <a>namespace IRI</a>
                        must be formally <em>declared</em> before its corresponding <a>prefix</a> may be used and there
                        is no explicit formal specification for how a pair should be treated or expressed.
                    </p>
                    <p>In contrast, [[RDF-CONCEPTS]] states that subjects are represented with an IRI which can be
                        conveniently
                        written as a <a>compact IRI</a> in the form <a>prefix</a>:<em>suffix</em>. In [[RDF-CONCEPTS]],
                        this <a>compact IRI</a> can be expanded via simple concatentation to reveal the subject IRI,
                        with
                        no deterministic way to return to the <a>compact IRI</a> form.
                    </p>
                    <p> The absence of a formal definition
                        of namespaces in [[RDF-CONCEPTS]] means that a document could contain overlapping prefixes where
                        different <a>compact IRIs</a> expand to the same IRI during concatenation, thus mangling their
                        namespaces.
                    </p>
                    <p>
                        <abbr title="Hierarchical Metadata Framework">HMF</abbr> chooses to follow [[XML]] defining a
                        <a>name</a> as an ordered pair and provides a <a>namespace registry</a> to map <a>prefixes</a>
                        to their <a>namespace IRIs</a>. The result is that all <a>names</a> belong to a specific
                        <a>namespace</a>.
                    </p>
                </div>
            </p>
            <section>
                <h3>Local Name</h3>
                <p>

                </p>
            </section>
            <section>
                <h3>Naming Restrictions</h3>

                <p>
                    The characters declared invalid within a local name (“/”, “:”, “[“, “]”, “|”, “*”) represent only
                    those
                    characters which are used as metacharacters in JCR names, paths and name-matching patterns (see
                    §5.2.2
                    Iterating Over Child Items). These restrictions are not necessarily sufficient to enforce best
                    practices
                    in
                    the creation of JCR names. In particular, the minimal grammar defined here permits JCR names with
                    leading
                    and trailing whitespace as well as characters which may appear superficially identical while
                    representing
                    different code points, creating a potential security issue.
                </p>
            </section>

            <section>
                <h3 id="empty-namespace">The Empty Namespace</h3>
                <p>
                    For trivial or single-source metadata applications, enforcing a <a>namespace</a> could be overly
                    burdensome. <abbr title="Hierarchical Metadata Framework">HMF</abbr> provides a permanent <a>default
                        namespace</a> with prefix <code>""</code> (i.e. the empty string), also referred to as the
                    <a>empty namespace</a>. This allows <a>names</a> to omit the <a>prefix</a> and be located using
                    their
                    <a>local name</a> only.
                </p>
            </section>
        </section>

        <section>
            <h2 id="annotations">Annotations</h2>
            <p>
                Annotations capture additional metadata about node&quot;s <a>properties</a> and relationships. For each
                <a>item</a> of a <a>node</a> we can access its <a>annotation</a> which is itself a collection of
                properties. Annotation properties can be of any type available to regular properties, however these
                properties are themselves not annotatable.
            </p>
            <p>
                <a>Nodes</a> that have the <a>mixin</a> type <code>mix:annotated</code> are said to be
                <em>annotated</em>. It's only possible to access annotations on nodes with this <a>mixin</a>
                type. The means for accessing annotations are implementation specific.
            </p>
            <p>
                <div class="note">
                    <p>The two popular graph-based data models have been RDF [[RDF11-CONCEPTS]] and
                        <a href="https://en.wikipedia.org/wiki/Graph_database#Labeled-property_graph">Labeled-property
                            Graphs</a>,
                        which are roughly similar, with the RDF model being more formal in identifying <a>nodes</a>,
                        datatypes and relationships, while Property Graphs
                        use a less formal relationship model somewhat similar to JSON. In both models,
                        nodes are related via edges (AKA arcs), but in Property Graphs,
                        those edges may themselves be annotated with properties.
                        This is useful in providing additional metadata and semantics to relationships
                        of the <a>nodes</a>.
                    </p>
                    <p>
                        <abbr title="Hierarchical Metadata Framework">HMF</abbr> takes a hybrid approach
                        by providing an RDF-style model that uses IRIs to formally identify <a>entities</a> whilst
                        allowing node properties and relationships to be annotated with additional metadata
                        as with labeled property graphs (LPGs).
                    </p>
                </div>
            </p>
            <p>
                Annotations are considered as part of a <a>node</a>&quot;s <a>versionable tree</a>.
                It is not currently possible to enforce mandatory annotations or any other property
                type declarations on annotation properties.
            </p>
            <section>
                <h3>Standard Annotations</h3>
                <p>
                    The following annotations enable functionality in HMF.
                </p>

                <table class="simple">
                    <thead>
                        <tr>
                            <th>Type <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>hmf:versionLabel</code></td>
                            <td>
                                Used to annotate <a>reference types</a> with a specific version label. When
                                the annotation reference property is resolved to a <a>node</a>, the version of
                                that <a>node</a> with the <a>version label</a> provided in this annotation
                                should be retrieved. It is assumed that the target node of the reference has the
                                <a>mixin</a> type <code>mix:versionable</code>. See [[[#versioned-reference]]].
                            </td>
                        </tr>
                        <tr>
                            <td><code>hmf:ordering</code></td>
                            <td>
                                Indicates whether the annotated multi-value property is <em>ordered</em> or
                                <em>un-ordered</em>. If the annotation has the value <code>list</code> then
                                the multi-value property is ordered. If the annotation has the value <code>set</code>
                                then the multi-value property is unordered. This annotation provides additional
                                semantics allowing clients to interpret a multi-value property appropriately.
                                If the annotated property is single-valued then this annotation is redundant.
                            </td>
                        </tr>
                    </tbody>
                </table>
                <p class="ednote" title="Ordering should be part of the type not the node">
                    We need to move the ordering to the property type definition.
                </p>

            </section>
        </section>
    </section>

    <section>
        <h2>Relationships &amp; Navigation</h2>
        <section class="informative">
            <h2>Introduction</h2>
            <p>
                HMF supports <em>type types</em> of relationships, <a>parent-child relationships</a> and <a>reference
                    relationships</a>. Parent-child relationships organise metadata into a structure that allows
                <a>items</a> to be <a>located</a> using <a>paths</a>.
            </p>
            <p>
                Parent-child relationships are bidirectional connections between a node and its child. These
                relationship
                are more than just associations, they imply that parent <em>contains</em> its child nodes or that
                child nodes <em>belong to</em> their parent. This containment or ownership relationship is
                transitive meaning that operations on a node can affect all descendents. For example, a delete
                (see [[[#move-copy-delete]]]) operation on a <a>node</a> is recursive and will delete all its child
                nodes and the child nodes of their child nodes, and so on.
            </p>
            <p>

            </p>
            <p>
                Reference relationships are a unidirectional connections between two arbitrary node. Reference
                relationships
                do not imply any
            </p>
        </section>
        <section>
            <h2>Relationships</h2>
            <section>
                <h3 id="parent-child-relationships">Parent-Child Relationships</h3>
                <p>
                    <abbr title="Hierarchical Metadata Framework">HMF</abbr> has <i>first-class</i> support for
                    <i>parent-child</i> relationships between <a>nodes</a>. Parent-child relationships have additional
                    semantics beyond what are provided for regular [[[#references]]]. For example, a child is considered
                    to belong to its parent, meaning that re-locating the parent also relocates the child. Versioning a
                    parent in many cases will also version the child. A parent's <a>type</a> may also enforce that it
                    has a child with a given <a>name</a> and <a>type</a>.
                </p>
                <p>
                    Parent-child relationships can be said to define the <a>tree</a> structure metadata.
                </p>
                <p>
                    <a>Trees</a> allow <a>paths</a> to be used to locate a <a>node</a>. <a>Paths</a> can only
                    be used to traverse <em>parent-child</em> relationships and do not apply to <a>references</a>.
                    <a>Nodes</a> can be referenced either using their identity or using their location as defined
                    by their <a>path</a> from the <a>root</a> to the <a>node</a>.
                </p>
                <p>
                    <a>Primary item</a> allows clients to navigate through parent-child relationships without
                    knowing the names of the intermediate
                </p>
                <p>
                    First class support in type system (types can declare child types)
                </p>
                <p>
                    <abbr title="Hierarchical Metadata Framework">HMF</abbr> does not support <a>same name siblings</a>.
                    That is, all children of a node must have a unique name.
                </p>
            </section>
            <section>
                <h3 id="references">Reference Properties</h3>
                <p>
                    A <a>node</a>
                </p>
                <section>
                    <h3 id="referenceable-type">Referenceable Type</h3>
                    <p>

                    </p>
                </section>
                <section>
                    <h4 id="strong-weak-references">Strong and Weak References</h4>
                    <p>

                    </p>
                </section>
                <section>
                    <h4 id="versioned-references">Versioned References</h4>
                    <p>
                        Versioned references allow a property to hold a reference to a specific version of a node,
                        guaranteeing that the reference resolves to an immutable and known node state. This is a
                        key building block for systems where a <em>stable</em> or <em>promoted</em> version of a
                        a <a>node</a> must be referenced whilst simultaneously edited.
                    </p>
                    <p>
                        <div class="illustration">
                            <p><img src="versioned-reference.png"
                                    alt="Annotation Specifying the Label of a Versioned Reference" width="700" /></p>
                            <p class="caption">Annotation Specifying the Label of a <a>Versioned Reference</a></p>
                        </div>
                    </p>
                    <p>
                        The annotation <code>hmf:versionLabel</code> should contain the <a>version label</a> of the
                        desired version. Clearly the target node should have the <a>mixin</a> type
                        <code>mix:versionable</code>.
                    </p>
                </section>

            </section>
            <section>
                <h3 id="primary-item">Primary Item</h3>
                <p>
                    A <a>node type</a> can declare <em>one</em> of its <a>item definitions</a> as primary, meaning that
                    for all <a>nodes</a> of that type, that <a>item</a> is accessible in a way that does not require the
                    name of the item. Primary item allow clients to traverse a <a>tree</a> without upfront knowledge of
                    the <a>node</a> structure.
                </p>
                <p>
                    A client could for example know to traverse a <a>tree</a>&quot;s primary item until a
                    <a>node</a> of a given <a>type</a> or <a>name</a> is encountered. This would allow editors to modify
                    a <a>tree</a>&quot;s structure, perhaps be adding or removing intermediate nodes, without breaking
                    the client.
                </p>
            </section>
        </section>
        <h2 id="paths">Paths</h2>
        <p>
            A HMF path allows an <a>item</a> to be resolved in terms of its <em>location</em> within the <a>tree</a>
            rather than its <em>identity</em>. In some scenarios, <em>location</em> is preferred over <a>identity</a>
            because resolution needs to happen with respect to a <a>node</a>&quot;s position relative to another
            <a>node</a>
            (including the <a>root</a>).
        </p>
        <section>
            <h3 id="path-segments">Path Segments</h3>
            <p>
                Paths are an ordered list of path <a>segments</a> <em>S = (P0,P1,...,PN)</em> of which there are the
                following types:
                <ul>
                    <li>A compact name segment with the <a>name</a> in its <a>prefix</a> form, such as
                        <code>acme:episode</code></li>
                    <li>An expanded name segment with the <a>name</a> in its expanded form, such as
                        <code>{http://acme.org/ns/}episode</code></li>
                    <li>the identifier segment where a <a>node</a> is identified by its identity</li>
                    <li>the versioned identifier segment where a version of a <em>versionable</em> node is identified
                        using the identity of its base version and a version <em>label</em></li>
                    <li>the versioned name segment where a version of a <em>versionable</em> node is identified
                        using its <a>name</a> and a version <em>label</em></li>
                    <li>the root segment which identifies the <a>root</a> node</li>
                    <li>the self segment which identifies the contextual node</li>
                    <li>the parent segment which identifies the parent <a>node</a> of the contextual node</li>
                </ul>
            </p>
            <p>
                The <em>root</em>, <em>self</em> and <em>parent</em> segments are constants with intuitive
                lexical forms as described in [[[#path-lexical-form]]].
            </p>
        </section>
        <section>
            <h4 id="segment-types">Segment Types</h4>

            <dl class="termlist" data-sort>
                <dt>
                    <dfn data-lt="compact name segments" class="preserve">compact name segment</dfn></dt>
                <dd>The <a>compact name segment</a> uses the <a>item</a> <a>name</a> in its <a>compact IRI</a> form.
                    That is, the segment consists of <a>prefix</a> and <a>local name</a> separated by a colon
                    (<code>:</code>). For example, <code>acme:title</code>.
                </dd>
                <dt>
                    <dfn data-lt="expanded name segments" class="preserve">expanded name segment</dfn></dt>
                <dd>The <a>expanded name segment</a> uses the namespace and <a>local name</a> in their expanded form.
                    That is, the segment consists of <a>namespace IRI</a> enclosed in braces <code>{}</code> and
                    the <a>local name</a>. For example, <code>{http://acme.org/ns}title</code> </dd>
                <dt>
                    <dfn data-lt="versioned name segments" class="preserve">versioned name segments</dfn></dt>
                <dd>The <a>versioned name segment</a> includes a name followed a version label enclosed in square
                    brackets <code>[]</code>. For example, <code>acme:title[version1]</code> or
                    <code>{http://acme.org/ns}title[version1]</code>
                </dd>
                <dt>
                    <dfn data-lt="identifier segments" class="preserve">identifier segment</dfn></dt>
                <dd>The <a>identifier segment</a> identifies a <a>node</a> using its unique identifer enclosed in
                    square brackets. For example, <code>[208a03d6-bb81-11ec-8422-0242ac120002]</code>.</dd>
                <dt>
                    <dfn data-lt="versioned identifier segments" class="preserve">versioned identifier segment</dfn>
                </dt>
                <dd>The <a>versioned identifier segment</a> combines the <a>identifier segments</a> with a version
                    label.
                    It therefore consists of the identifier enclosed in square brackets <code>[]</code> followed
                    by the version label in square brackets <code>[]</code>.
                    For example, <code>[208a03d6-bb81-11ec-8422-0242ac120002][version1]</code></dd>
                <dt>
                    <dfn data-lt="root segments" class="preserve">root segment</dfn></dt>
                <dd>The <a>root segment</a> identifies the root of the repository. It is identified as the absence of
                    a value.
                </dd>
                <dt>
                    <dfn data-lt="self segments" class="preserve">self segment</dfn>
                </dt>
                <dd>The <a>self segment</a> identifies the context node. It takes the form of a single period:
                    <code>.</code>.
                </dd>
                <dt>
                    <dfn data-lt="parent segment" class="preserve">parent segment</dfn></dt>
                <dd> The <a>parent segment</a> identifies the parent of the context node. It takes the form of two
                    periods:
                    <code>..</code>.
                </dd>
            </dl>
        </section>
        <section>
            <h4>Relative Paths & Context Nodes</h4>
            <p>
                Relative paths start with the <a>self segment</a>.
            </p>
        </section>


        <section>
            <h3 id="path-lexical-form">Lexical Form</h3>
            <p>

            </p>
        </section>
        <section>
            <h3 id="traversal">Path Traversal</h3>
            <p>
                Intermediate nodes may not exist due to permission restrictions
            </p>
        </section>
    </section>

    <section>
        <h2 id="types">Types</h2>
        <section class="informative">
            <h3>Introduction</h3>
            <p>
                Types are a fundamental and foundational component of <abbr
                    title="Hierarchical Metadata Framework">HMF</abbr>
                since they are the means for <em>domain knowledge</em> to be formalised within the model.
                Types capture the characterstics and structure of a given metadata model and offer strong
                guarantees about the data it holds.
            </p>
            <p>
                Types provide a <em>classification</em> to <a>nodes</a> and <a>properties</a>. This classification
                indicates the range of possible values that can be held and in the case of <a>nodes</a>, the
                types of child <a>nodes</a> it may posses. ...
            </p>
            <p>
                In HMF there are three types of type definition:
                <ul>
                    <li><em>Node Type Definition</em> - defines a node type within the model including which primary
                        types in inherits from, which <a>mixin</a> types it carries, whether it declares a <a>primary
                            item</a> and so on. It also acts as a container for <a>property type definitions</a> and
                        <a>child node type definitions</a>.</li>
                    <li><em>Property Type Definition</em> - defines the type and contraints of a <a>property</a>
                        including its value type, whether it is single-valued or multi-values, whether it is
                        mandatory and so on.
                    </li>
                    <li><em>Child Node Type Definition</em> - defines the type and constraints of a child node
                        including its primary types, whether the child node is mandatory and details of how the
                        child node should be auto-created if needed.</li>
                </ul>
            </p>

            <div class="illustration">
                <img src="node-type-def.png" alt="Node Type Definition" width="600" />
                <p class="caption">Shows a <a>node type definition</a> with the <a>name</a> <code>acme:content</code>.
                    It declares two <a>properties</a> via two <a>property type definitions</a> for
                    <code>acme:title</code>
                    and <code>acme:genres</code>, along with a <a>residual</a> <a>child node definition</a> declaring
                    that all child <a>nodes</a> of this <a>type</a> must be of the type <code>acme:show</code>.
                </p>
            </div>

            <p>
                Node types may be dynamically modified within an application assuming the changes are compatible
                with all <a>nodes</a> of that type. For example, a new <em>non-mandatory</em> field or a
                mandatory field with a default value may be added to a node type. If a node type applies further
                restrictions, then all <a>nodes</a> with that type must first conform to those restrictions before
                the modification will be allowed.
            </p>
            <p>
                Node types may be dynamically applied <a>nodes</a> within a <a>tree</a>. This means that once a
                node conforms to a given type, that type may be applied as its primary type or <em>mixed-in</em>
                to that node. This allows editorial pipelines to be constructed where additional types are added
                to metadata as it matures through the system.
            </p>
        </section>

        <section class="informative">
            <h3 id="node-types">Node Types</h3>
            <section>
                <h4 id="primary-type">Node Primary Type</h4>
                <p>
                    Every <a>node</a> has a single declared primary type. Nodes have an <em>is-a</em> relationship
                    with the primary type. The primary type of a node typically defines the core characteristics of the
                    node in the domain model. This is in contrast to mixin nodes which add additional and supplimentary
                    functionality or metadata.
                </p>
                <p>Given that primary types may inherit from one another, a node can be said to have multiple types
                    or formally, multiple <a>supertypes</a>. Implementations should provide the means for clients to
                    acquire all supertypes of a node.
                </p>
                <p>
                    The default primary type of a node is <code>hmf:base</code> (see [[[#builtin-primary-types]]]).
                </p>
            </section>
            <section>
                <h4>Mixin Types</h4>
                <p>
                    A <a>node</a> may have zero or more <a>mixin types</a>. Mixin types provide a way to compose
                    functionality or key metadata (such as standardized metadata, see [[[#builtin-mixins]]])
                    on a node. They are used to mark nodes as eligible for some model or repository feature such as
                    <code>mix:annotated</code> (see [[[#annotations]]]) and <code>mix:versionable</code> (see
                    [[[#versioning]]]).
                </p>
                <p>
                    Mixin types may not be used as a primary type of a node, however they can be used as supertypes
                    of primary types. Only mixin types may be supertypes of mixin types.
                </p>
            </section>
            <section>
                <h4 id="node-type-inheritance">Node Type Inheritance</h4>
                <p>
                    Both primary types and mixin types can take advantage of inheritance which allows a node type
                    to inherit from a supertype or parent node type definition. Subtypes inherit the parent
                    property and child node type definitions, including any such definitions themselves inherited
                    from the parent&quot;s supertype. The resulting definition known as the <a>effective node type</a>
                    is the sum of all inherited type definitions.
                </p>
                <p class="ednote" title="Define override rules">
                    Expand by defining the inheritance rules when a subtype redefines a property name already
                    defined on the parent.
                </p>
            </section>
            <section>
                <h4 id="multiple-inheritance">Multiple Inheritance</h4>
                <p>

                </p>
            </section>
            <section>
                <h4>Updating the Primary Type</h4>
                <p>
                    The <a>primary type</a> of a node may be modified after node creation. This is a key capability
                    of HMF since it allows for progressive typing during the lifecycle of a metadata <a>tree</a>.
                    The primary type of a node may only be changed if all mandatory <a>items</a> are already present
                    on that node.
                </p>
            </section>
            <section>
                <h4>Node Type Versioning</h4>
                <p>
                    Node types can be optionally versioned. Modifications to the node type will result in a version
                    increment.
                </p>
                <p class="ednote" title="Needs expanding">
                    Needs expanding
                </p>
            </section>
        </section>
        <section>
            <h3 id="node-type-definition">Node Type Definition</h3>
            <p>

            </p>
            <section>
                <h4>Name</h4>
                <p>
                    Every node type registered with the repository has a unique <a>name</a>. The naming conventions for
                    node types are the same as for items and are described in [[[#names]]].
                </p>
            </section>
            <section>
                <h4>Version</h4>
                <p>
                    Provides a version identifier (typically as an incrementing integer) for the node type.
                </p>
            </section>
            <section>
                <h4>Supertypes</h4>
                <p>
                    A primary node type (with the exception of <code>hmf:base</code>) must extend another node type (and
                    may extend more than one node type). A <a>mixin</a> node type may extend another node type.
                </p>
            </section>
            <section>
                <h4>Is Abstract</h4>
                <p>
                    A node type may be declared abstract, meaning that it cannot be assigned as the primary or mixin
                    node type of a node but can be used in the definition of other node types as a supertype.
                    Abstract node types are therefore used to define common types that do not themselves function
                    as a standalone node type.
                </p>
            </section>
            <section>
                <h4>Is Mixin</h4>
                <p>
                    A node type may be declared as either a <a>mixin type</a> or a <a>primary node type</a>.
                    If it is declared as a <a>mixin type</a> then it may not be used as a primary type of a
                    node however a primary type may inherit from a mixin type.
                </p>
            </section>
            <section>
                <h4>Primary Item</h4>
                <p>
                    A node type may specify one child item (property or node) by name as the primary item. A primary
                    item is an item on a node that is considered <em>primary</em> or <em>default</em>, and may be
                    accessed from the declaring node without requiring the <a>name</a>. Primary items are commonly
                    used to allow clients to navigate through intervening until they reach a node of the desired
                    type.
                </p>
            </section>
            <section>
                <h4>Property Type Definitions</h4>
                <p>
                    A node type typically (although not always) declares one or more <a>property type definitions</a>
                    controlling which properties are restricted or permitted.
                </p>
            </section>
            <section>
                <h4>Child Node Type Definitions</h4>
                <p>
                    A node type typically (although not always) declares one or more <a>child node type definitions</a>
                    controllnig which child nodes are restricted or permitted.
                </p>
            </section>
            <section>
                <h4>Node Type Documentation</h4>
                <p>
                    A <code>hmf:documentation</code> property may be added to a node type definition containing a
                    <code>type:string</code> value.
                </p>
            </section>
        </section>
        <section>
            <h3 id="property-type-definition">Property Definition</h3>
            <p>
                A <a>property definition</a> on a node controls the behaviour of a <a>property</a> and the <a>values</a>
                it may contain. A <a>property definition</a> may declare the following:
                <ul>
                    <li><em>Name</em> - The <a>name</a> of the <a>property</a> to which this definition
                        applies, or <code>*</code> if this definition is a <a>residual definition</a>, meaning that it
                        applies to any additional properties with any names apart from those otherwise defined in this
                        node type (see [[[#residual-definition]]]).</li>
                    <li><em>Required type</em> - defines the datatype of the value held by the <a>property</a></li>
                    <li><em>Value constraints - The value constraints on the property define the range of values that
                            may be assigned to this property.</em></li>
                    <li><em>Default value</em> - The value that the property will have if it is auto-created.</li>
                    <li><em>Auto-created status</em> - Whether this property will be auto-created when its parent node
                        is created. Only properties with a default value can be auto-created.</li>
                    <li><em>Mandatory status</em> - A mandatory property is one that must exist. If a node of a type
                        that specifies a mandatory property is created then any attempt to save that node without adding
                        the mandatory property will fail. Since single-value properties either have a value or do not
                        exist (there being no concept of the <code>null</code> value) this implies that a mandatory
                        single-value property must have a value. A mandatory multi-value property on the other hand may
                        have zero or more values.</li>
                    <li><em>Mutliple values status</em> - Whether this property can have multiple values, meaning that
                        it stores an array of values, not just one.
                    </li>
                    <li><em>Multiple values semantics status</em> - If the property contains multiple values,
                        determines if the property has <em>list</em> or <em>set</em> semantics. List semantics
                        indicates that the values are ordered. Set semantics indicates that the values are not ordered.
                    </li>
                    <li><em>On-Parent-Version status</em> - The On-Parent-Version status of specifies what happens to
                        this property if a new version of its parent node is created (i.e. a checked-in is done on it).
                    </li>
                    <li><em>Description</em> - Provides a narrative description of the property.</li>

                </ul>
            </p>
            <section>
                <h4>Name</h4>
                <p>
                    The <a>name</a> of the <a>property</a> to which this definition
                    applies, or <code>*</code> if this definition is a <a>residual definition</a>, meaning that it
                    applies to any additional properties with any names apart from those otherwise defined in this
                    node type (see [[[#residual-definition]]]).
                </p>
            </section>
            <section>
                <h4 id="residual-property-definition">Residual Property Definition</h4>
                <p>
                    When the <a>name</a> attribute of the node type definition is <code>*</code> (asterisk),
                    it specifies that the definition is <a>residual</a>, meaning that its scope consists of all other
                    properties
                    (child nodes), which are not otherwise scoped by any of the other property (child node) definitions
                    in the effective node type of the node (see [[[#effective-node-type]]]).
                </p>
            </section>
            <section>
                <h4 id="property-required-type">Standard Required Types</h4>
                <p>
                    The following <i>standard</i> required types are defined, although a <a>repository</a> may choose to
                    support additional <a>types</a>:
                    <table class="simple">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Datatype <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>string</td>
                                <td><code>type:string</code></td>
                                <td>A sequence of characters encoded as UTF-8</td>
                            </tr>
                            <tr>
                                <td>boolean</td>
                                <td><code>type:boolean</code></td>
                                <td>The value of <code>true</code> or <code>false</code></td>
                            </tr>
                            <tr>
                                <td>long</td>
                                <td><code>type:long</code></td>
                                <td>An integer with a minimum value of -2<sup>63</sup> and a maximum value of
                                    2^<sup>63-1</sup>.
                                </td>
                            </tr>
                            <tr>
                                <td>double</td>
                                <td><code>type:double</code></td>
                                <td>A double-precision 64-bit IEEE 754 floating point.
                                </td>
                            </tr>
                            <tr>
                                <td>decimal</td>
                                <td><code>type:decimal</code></td>
                                <td>...</td>
                            </tr>
                            <tr>
                                <td>date</td>
                                <td><code>type:date</code></td>
                                <td>An [[ISO8601]] date</td>
                            </tr>
                            <tr>
                                <td>weakreference</td>
                                <td><code>type:weakreference</code></td>
                                <td>An identifer to a referenceable node <i>without</i> enforced referential
                                    integrity.
                                </td>
                            </tr>
                            <tr>
                                <td>reference</td>
                                <td><code>type:reference</code></td>
                                <td>An identifer to a referenceable node <i>with</i> enforced referential integrity.
                                </td>
                            </tr>
                            <tr>
                                <td>uri</td>
                                <td><code>type:uri</code></td>
                                <td>A sequence of characters that conform to [[RFC3987]]</td>
                            </tr>
                            <tr>
                                <td>path</td>
                                <td><code>type:path</code></td>
                                <td>A <a>path</a> in either <a>absolute</a> or <a>relative</a> form represented in
                                    its
                                    lexical (string) form</td>
                            </tr>
                            <tr>
                                <td>undefined</td>
                                <td><code>type:undefined</code></td>
                                <td>A special type indicating that there is no required type. This is only used
                                    in type declarations and all properties in the <a>tree</a> must have
                                    one of the other available types. <code>type:undefined</code> is commonly used
                                    in <a>residual definitions</a>, see [[[#residual-property-definition]]]
                                    and [[[#residual-child-node-definition]]].</td>
                            </tr>
                        </tbody>
                    </table>
                </p>
            </section>
            <section>
                <h3>Values Constraints</h3>
                <p>
                    Value constraints limit the range of possible values that a property can hold. They are
                    an extension to the restrictions enforced by the value type (see [[[#property-required-type]]])
                    and allow for further modelling of the metadata domain.
                </p>
                <section>
                    <h4><code>type:string</code> Constraints</h4>
                    <p>Constraints on <code>type:string</code> are expressed as <em>regular expressions</em>. The
                        exact implementation of regular expression used is implementation specific.</p>
                </section>
                <section>
                    <h4>Numeric Type Constraints</h4>
                    <p>Types <code>type:long</code>, <code>type:decimal</code>, <code>type:double</code> and
                        <code>type:date</code> may be subject to <em>numerical</em> constraints limiting
                        the range of possible values available. This is achieved using a comma separated
                        pair including an <em>upper</em> and <em>lower</em> bound in the form enclosed in either
                        a square bracket <code>[]</code> or parenthesis <code>()</code>. The square brackets
                        <code>[]</code> indicate inclusivity and the parenthesis <code>()</code> indicate
                        exclusivity.
                    </p>
                    <p>
                        Some examples:
                        <ul>
                            <li><code>[0,100]</code> - an <em>inclusive</em> range permitting the integers
                                <code>0</code> to <code>100</code></li>
                            <li><code>(0,100)</code> - an <em>exclusive</em> range permitting the integers
                                <code>1</code> to <code>99</code></li>
                            <li><code>[1649627836,]</code> - this indicates any value <code>1649627836</code>
                                or greater. If this was a date then it would represent any date on or after
                                <em>Sunday, 10 April 2022 22:57:16 GMT+01:00</em>.</li>
                            <li><code>[200,500)</code> - an <em>inclusive floor</em> and <em>exclusive ceiling</em>
                                permitting integers in the range <code>200</code> to <code>499</code></li>
                            <li><code>[,500)</code> - any integer up to <code>499</code></li>
                        </ul>
                    </p>
                </section>
                <section>
                    <h4><code>type:path</code> Constraints</h4>
                    <p>Path constraints can either prescribe a specific allowed path or an allowed ancestor if
                        terminating in <code>/*</code>. These constraints allow the model to enforce that a
                        property can only refer to specific paths or subpaths.
                    </p>
                    <p>
                        Some examples:
                        <ul>
                            <li><code>/path/to/node</code> - the path must be equal to this value</li>
                            <li><code>/path/to/ancestor/*</code> - the path must start with
                                <code>/path/to/ancestor</code></li>
                        </ul>
                    </p>
                </section>

            </section>
            <section>
                <h3 id="default-values-property">Default Values</h3>
                <p>
                    The default value of a property is the value assigned to a property if it is auto-created
                    (see [[[#auto-created-property]]]). This may be a single value or multiple values depending
                    on the [[[#single-multi-value-properties]]]. The default value must have the same value type
                    as the property it is defined on.
                </p>
            </section>
            <section>
                <h3 id="auto-created-property">Auto-created Values</h3>
                <p>
                    A property may be declared auto-created, meaning that it is automatically created upon creation
                    of
                    its parent <a>node</a> or the moment that the property becomes part of a node&quot;s type. If no
                    value is supplied during <a>node</a> creation then the default value is used (see
                    [[[#default-values-property]]]). Auto-created values are especially useful when
                    adding mandatory properties to node types.
                </p>
                <p>
                    <div class="note">
                        Properties may be auto-created if the node implicitly acquires the property from one
                        of its <a>supertypes</a> or if a <a>mixin</a> type is added to a node type. For example,
                        adding <code>mix:created</code> implies the addition of <code>hmf:created</code> and
                        <code>hmf:createdBy</code> which should be
                    </div>
                </p>
            </section>
            <section>
                <h4 id="mandatory-properties">Mandatory status</h4>
                <p>
                    A property may be marked as <em>mandatory</em>. If the property is single-valued then a
                    value must be present for that property and there is no <code>null</code> value. If the
                    property is multi-valued it may have zero or more values. If a <a>node</a> defines a
                    property that single-valued and mandatory then it must be supplied during node-creation
                    otherwise an error is raised.
                </p>
            </section>
            <section>
                <h4 id="single-multi-value-properties">Mutliple values status</h4>
                <p>
                    Whether this property can have multiple values, meaning that
                    it stores an array of values, not just one.
                </p>
            </section>
            <section>
                <h4>Collection semantics</h4>
                <p>
                    If the property contains multiple values, determines if the property has <em>list</em> or
                    <em>set</em> semantics. List semantics indicates that the values are ordered. Set semantics
                    indicates that the values are not ordered.
                </p>
            </section>
            <section>
                <h4>On-Parent-Version status</h4>
                <p>
                    The On-Parent-Version (OPV) status of specifies what happens to this property if a new version of
                    its
                    parent node is created (i.e. a checked-in is done on it). See [[[#on-parent-version]]].
                </p>
            </section>
            <section>
                <h3 id="protected-property">Protected Properties</h3>
                <p>
                    Protected properties are properties that are managed by the implementation and
                    cannot be modified by clients. Protected properties are read-only by clients and
                    read-write for implementations.
                </p>
            </section>
            <section>
                <h4>Description</h4>
                <p>
                    Holds a narrative description of the <a>property</a>.
                </p>
            </section>
        </section>
        <section>
            <h3 id="child-node-definition">Child Node Definition</h3>
            <p>
                TODO
            </p>
            <section>
                <h4>Name</h4>
                <p>
                    The <a>name</a> of the child node to which this definition applies or the wildcard <code>*</code> if
                    this definition is a <a>residual definition</a>, meaning that it applies to any additional child
                    nodes with any names apart from those otherwise defined in this node type (see
                    [[[#residual-child-node-definition]]]).
                </p>
            </section>
            <section>
                <h4 id="residual-child-node-definition">Residual Child Node Definition</h4>
                <p>
                    When the <a>name</a> attribute of the node type definition is <code>*</code> (asterisk),
                    it specifies that the definition is <a>residual</a>, meaning that its scope consists of all other
                    child nodes, which are not otherwise scoped by any of the other child node definitions in the
                    effective node type of the node (see [[[#effective-node-type]]]).
                </p>
            </section>
            <section>
                <h4>Required primary types</h4>
                <p>
                    If it specifies only a single node type <code>N</code> then the primary node type of this child node
                    must be <code>N</code> or a subtype of <code>N</code>. If this attribute specifies multiple node
                    types
                    <code>N<sub>1</sub></code>, <code>N<sub>2</sub></code>,<code>...</code>, <code>N<sub>M</sub></code>
                    then the primary node type of this child node must be a subtype of all the types
                    <code>N<sub>1</sub></code>, <code>N<sub>2</sub></code>, … <code>N<sub>M</sub></code>.
                    See [[[#multiple-inheritance]]] for a discussion of type inheritance and subtyping rules.
                </p>
            </section>
            <section>
                <h4>Default primary type</h4>
                <p>
                    This is the primary node type automatically assigned if no node type information is specified when
                    the node is created.
                </p>
            </section>
            <section>
                <h4>Auto-create status</h4>
                <p>
                    Governs whether this child node will be auto-created when its parent node is created.
                </p>
            </section>
            <section>
                <h4>Mandatory status</h4>
                <p>
                    Governs whether the child node is mandatory. A mandatory child node is one that must exist. If a
                    mandatory child node is missing from a parent node then save on the parent node will fail.
                </p>
            </section>
            <section>
                <h4>On-Parent-Version status</h4>
                <p>
                    This specifies what to do with the child node if its parent node is versioned. See See
                    [[[#on-parent-version]]].
                </p>
            </section>

        </section>
        <section>
            <h3 id="effective-node-type">Effective Node Type</h3>
            <p></p>
        </section>
        <section>
            <h3 id="residual-definition">Residual Definitions</h3>
            <p></p>
        </section>
        <section>
            <h3>Builtin Types</h3>
            <section>
                <h4 id="builtin-primary-types">Builtin Primary Types</h4>
                <p>

                </p>
                <table class="simple">
                    <thead>
                        <tr>
                            <th>Type <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>hmf:base</code></td>
                            <td>
                                This is the base type of all primary node types and therefore all nodes in a
                                HMF model. It exposes the mandatory property <code>hmf:primaryType</code>
                                and the optional property <code>hmf:mixinTypes</code>. This is the only
                                type in the model that does not itself extend another type.
                            </td>
                        </tr>
                        <tr>
                            <td><code>hmf:versionHistory</code></td>
                            <td>
                                Holds the <a>version history</a> of a <a>node</a> in the <a>working tree</a>.
                                It acts as the parent of all <a>version nodes</a> of a <a>versionable node</a>
                                and holds the <a>version labels</a> for the various <a>versions</a>.
                            </td>
                        </tr>
                        <tr>
                            <td><code>hmf:version</code></td>
                            <td>
                                Holds metadata about a <a>version node</a> including the date that it was
                                created and the sets of ancestor and predecessor nodes. The version node
                                also contains the <a>frozen node</a> holding the snapshot-state of the
                                <a>versionable node</a> for this version. See [[[#version-metadata]]].
                            </td>
                        </tr>
                        <tr>
                            <td><code>hmf:frozenNode</code></td>
                            <td>
                                Holds a copy of the <a>versionable node</a> in version storage. It also
                                holds copies of the core metadata in the properties <code>hmf:frozenPrimaryType</code>,
                                <code>hmf:frozenMixinTypes</code> and <code>hmf:frozenUuid</code> (as not to collide
                                with the properties already held on <code>hmf:frozenNode</code>). See
                                [[[#version-metadata]]].
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section>
                <h4 id="builtin-mixins">Builtin Mixin Types</h4>
                <table class="simple">
                    <thead>
                        <tr>
                            <th>Type <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>mix:created</code></td>
                            <td>
                                Used to add standardized information about the creation of the node via the
                                properties
                                <code>hmf:created</code> (providing the timestamp that the node was created) and
                                <code>hmf:createdBy</code> (providing the principal that created the node).
                                In cases where the <a>mixin</a> is applied to an already created node, these
                                properties
                                must be auto-created with values as-determined by the implementation.
                            </td>
                        </tr>
                        <tr>
                            <td><code>mix:modified</code></td>
                            <td>
                                Used to add standardized information about the modification of the node via the
                                properties
                                <code>hmf:modified</code> (providing the timestamp that the node was modified) and
                                <code>hmf:modified</code> (providing the principal that modified the node).
                                In cases where the <a>mixin</a> is applied to an already created node, these
                                properties
                                must be auto-created.
                            </td>
                        </tr>
                        <tr>
                            <td><code>mix:versionable</code></td>
                            <td>
                                Indicates that the <a>node</a> is subject to versioning. See [[[#versioning]]].
                            </td>
                        </tr>
                        <tr>
                            <td><code>mix:annotated</code></td>
                            <td>
                                Indicates that the <a>node</a> carries annotations. See [[[#annotations]]]
                            </td>
                        </tr>
                        <tr>
                            <td><code>mix:referenceable</code></td>
                            <td>
                                Indicates that the <a>node</a> may be the subject of a <a>reference</a>. See
                                [[[#references]]].
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>
        </section>
    </section>

    </section>
    <section>
        <h2 id="versioning">Versioning</h2>
        <section class="informative">
            <h3>Introduction</h3>
            <p>
                Versioning is enabled via <a>version storage</a>; a separate area of the metadata
                model dedicated to storing and managing historical snapshots of <a>nodes</a> and their
                <a>subtrees</a>. Versionable <a>nodes</a> (i.e. those with the type <code>mix:versionable</code>)
                hold references to the historical <a>node</a> snapshots so that they can be discovered
                and acted upon. A <a>node</a> that does not carry the <code>mix:versionable</code> type
                cannot be versioned.
            </p>
            <p>
                A <a>versionable</a> <a>node</a> can be <em>checked-in</em> and <em>checked-out</em>.
                Checking-in creates a <em>new version</em> of the node state along with its <a>versionable
                    subtree</a>. This new version is appended to the version
                history (see [[[#version-history]]]) held within <a>version storage</a> where it can be
                later accessed.
            </p>
            <div class="illustration">
                <p><img src="version-history-simple.png" alt="Simple Versioning Representation" width="700" /></p>
                <p class="caption">A <a>node</a> <code>N</code> with versionable child <code>C</code>
                    along with its version history. Version <code>N<sub>V2</sub></code> is expanded in the
                    illustration showing that the versionable child <code>C<sub>V2</sub></code> is also
                    persisted.
                </p>
            </div>
            <p>
                One of the versions in the version history is marked as the <a>base version</a>. The base
                version is the version against which modifications to a checked-out node are made. That is,
                any changes between the base version and the checked-out node are considered as <a>
                    versionable changes</a>. When node
            </p>
            <p>
                The rules that govern what the version snapshot will include are governed entirely by the <em>on-parent
                    versioning</em> (OPV) attribute of the property definitions and child node definitions defined by
                the primary type and/or mixin types of the versionable node. That is, the <a>types</a> of a <a>node</a>
                prescribe how their data will be managed with respect to versionable state.
            </p>
            <p>
                Each version within a <a>version history</a> can be identified through zero or more labels.

            </p>
        </section>
        <section>
            <h3 id="versionable-nodes">Versionable Nodes</h3>
            <p>
                All <a>nodes</a> (subject to the On-Parent-Version rules outlined in [[[#on-parent-version]]]) may be
                tracked with HMF versioning however only nodes that have the <a>type</a> <code>mix:versionable</code>
                may be checked-in and checked-out (see [[[#checked-in-out]]]). That is, a <a>version node</a> may only
                track a <a>versionable node</a>. Only versionable nodes-trees may be restored.
            </p>
        </section>
        <section>
            <h3 id="checked-in-out">Checked-in &amp; Checked-out State</h3>
            <p>
                A new version of a versionable node is created by checking-in a versionable node. In this state the node
                and its versionable subgraph are read-only. The node can then be checked-out at which point it becomes
                writable again.
            </p>
            <p>
                Checking-in an already checked-in node does nothing. Checking-in a non-versionable node is not
                permitted.
                Checking-in a <a>versionable</a> node stores that node&quot;s <a>versionable state</a> and updates the
                <a>base version</a> of the node.
            </p>
        </section>
        <section>
            <h3>Accessing Versions and Versioned State</h3>
            <p>
                <a>Versionable nodes</a> inherit the <a>reference property</a> <code>hmf:versionHistory</code>
                from <code>mix:versionable</code>. This is a <a>strong reference</a> which can be followed
                to a node of type <code>hmf:versionHistory</code>. The <code>hmf:versionHistory</code> node
                has a set of child nodes of type <code>hmf:version</code> which represent each tracked
                (checked-in) version.
            </p>
            <div class="illustration">
                <p><img src="accessing-versions.png" alt="Accessing Version State" width="600" /></p>
                <p class="caption">
                    Node <code>N<sub>1</sub></code> holds references to the <a>version history</a> and
                    <a>base version</a> through the properties <code>hmf:versionHistory</code> and
                    <code>hmf:baseVersion</code> respectively. The version history contains a child relationships
                    to each version (i.e. with type <code>hmf:version</code>). The <code>hmf:version</code>
                    node itself holds a <a>frozen node</a> which holds the checked-in state of the node
                    <code>N<sub>1</sub></code>.
                </p>
            </div>
            <p>
                The <code>hmf:baseVersion</code> reference on the versionable node holds a reference to the
                version from which changes to the node will be tracked, known as the <a>base version</a>.
                That is, when a node is checked out it holds the state from the <a>base version</a>. A fresh
                check-in will create a new successor in the version history and the base version will be
                moved to the version created by the check-in.
            </p>
        </section>
        <section>
            <h3 id="version-history">Version History</h3>
            <p>
            </p>
        </section>
        <section>
            <h3 id="frozen-node">Frozen Node</h3>
            <p>
            </p>
        </section>

        <section>
            <h3 id="version-metadata">Version Metadata</h3>
            <p>
                The following fields are available on the version, as defined by the type <code>hmf:version</code>:
            </p>
            <table class="simple">
                <thead>
                    <tr>
                        <th>Property</th>
                        <th>Type</th>
                        <th>Multiple Status</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>hmf:created</code></td>
                        <td><code>type:date</code></td>
                        <td>single</td>
                        <td>
                            Provides the date that the version was created
                        </td>
                    </tr>
                    <tr>
                        <td><code>hmf:predecessors</code></td>
                        <td><code>type:reference</code></td>
                        <td>multiple</td>
                        <td>
                            Provides the direct predecessors of the version history. This is typically
                            a single predecessor.
                        </td>
                    </tr>
                    <tr>
                        <td><code>hmf:successors</code></td>
                        <td><code>type:reference</code></td>
                        <td>multiple</td>
                        <td>
                            Provides the direct successors of the version history. This is typically
                            a single successor.
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>
        <section>
            <h3 id="version-labels">Version Labels</h3>
            <p>
                A zero or more labels can be applied to the version during check-in. The version may be later retrieved
                using one of the labels. Two versions cannot have the same label.
            </p>
        </section>
        <section>
            <h3 id="versionable-state">Versionable State</h3>
            <p>
                The versionable state of a versionable node is typically a subset of its subtree. That is, when a node
                is versioned it may also include some or all of its descendent nodes and their properties.
            </p>
            <p>
                The descendents of a <a>versionable node</a> <code>N</code> that belong to its <a>versionable state</a>
                are determined by the <a>on-parent version</a> status of the child nodes of <code>N</code> (grand-child
                nodes of <code>N</code> do not have their <a>on-parent-version</a> status considered, however they
                do form part of the versionable state). This is best described through an illustration:
            </p>
            <div class="illustration">
                <p><img src="versionable-state.png" alt="Versionable State of N" width="800" /></p>
                <p class="caption">
                    Illustrates the <a>versionable state</a> of node <code>N</code>. <code>N</code> has
                    three child nodes each with different <a>on-parent-version</a> declarations.
                    Child node <code>C<sub>1</sub></code> has an OPV of <code>COPY</code> meaning its
                    child <code>G<sub>1</sub></code> is versionable state.
                    <code>C<sub>2</sub></code>
                    has an OPV of <code>IGNORE</code> meaning it is excluded from the versionable state
                    along with its child.
                    Child node <code>C<sub>3</sub></code> has as an OPV of <code>VERSION</code> meaning
                    that the versionable state becomes a reference to the version history of
                    <code>C<sub>3</sub></code>: <code>V<sub>C3</sub></code>.
                </p>
            </div>
            <p>
                The details of the various OPV values are described in [[[#on-parent-version]]].
            </p>
        </section>
        <section>
            <h3 id="on-parent-version">On-Parent-Version (<abbr title="On-Parent-Version">OPV</abbr>)</h3>
            <p>
                When a <a>versionable</a> <a>node</a> <code>N</code> is checked in, all of the child nodes will be
                evaluated based upon the <em>child node definition</em> (see [[[#child-node-definition]]]) for those
                nodes on <code>N</code>.
                That is, given a child <code>C</code>, the applicable child node definition from the primary type or
                mixin type <code>N<sub>def</sub>C</code> on <code>N</code> for <code>C</code> will be considered as
                follows:
                <ul>
                    <li>if the child node definition <code>N<sub>def</sub>C</code> has an OPV of <code>copy</code>, then
                        the entire subgraph starting at node <code>C</code> will be
                        copied into the version snapshot, regardless of the descendants' OPV settings</li>
                    <li>if the child node definition <code>N<sub>def</sub>C</code> has an OPV of <code>version</code>,
                        then the snapshot will simply contain a placeholder node (of primary type
                        <code>hmf:versionedChild</code>') pointing to the versioned child node</li>
                    <li>if the child node definition <code>N<sub>def</sub>C</code> has an OPV of <code>abort</code>,
                        then an exception will be thrown </li>
                    <li>if the child node definition <code>N<sub>def</sub>C</code> has an OPV of <code>ignore</code> or
                        <code>initialize</code> or <code>compute</code>, then the child node will not be included in the
                        snapshop</li>
                </ul>
                <p class="note">Note that an OPV of COPY can be expensive if the subgraph of that child node contains a
                    lot of descendants.</p>
            </p>
        </section>
        <section>
            <h3 id="versioned-reference">Referencing a Version</h3>
            <p>
                The reference property type holds an identifier to a <a>referenceable node</a>. <a>Version nodes</a>
                are not referenceable. A reference relationship to a <a>versionable node</a> may specify the intended
                version by <a>annotating</a> the reference with standard annotation property
                <code>hmf:versionLabel</code> (see [[[#standard-annotations]]]) with value set as the desired version
                label.
            </p>
        </section>
    </section>
    <section>
        <h2 id="repository">Repository</h2>
        <section class="informative">
            <h3>Introduction</h3>
            <p>
                HMF documents represent HMF <a>trees</a> on disk or on the wire. When HMF trees enter a
                repository they acquire additional behaviour and semantics. This section specifies the
                repository.
            </p>
        </section>

        <section>
            <h3 id="repository-node">Repository Node - <code>hmf:repository</code></h3>
            <p>
                The <a>repository node</a> provides metadata about the repository including features it supports
                and links to other resources within the model.
            </p>
            <table class="simple">
                <thead>
                    <tr>
                        <th>Definition Type</th>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Mandatory Status</th>
                        <th>Multiple Status</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Property</td>
                        <td><code>hmf:namespace</code></td>
                        <td><code>type:string</code></td>
                        <td>optional</td>
                        <td>single</td>
                        <td>
                            A reference property pointing to the <code>hmf:namespaceRegistry</code>.
                        </td>
                    </tr>
                    <tr>
                        <td>Property</td>
                        <td><code>*</code></td>
                        <td><code>*</code></td>
                        <td>-</td>
                        <td>-</td>
                        <td>
                            Allows for any property to be added to the <a>repository node</a>.
                        </td>
                    </tr>
                    <tr>
                        <td>Child</td>
                        <td><code>*</code></td>
                        <td><code>*</code></td>
                        <td>-</td>
                        <td>-</td>
                        <td>
                            Allows for any child to be added to the <a>repository node</a>.
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h3>Repository Root</h3>
            <p>

            </p>
        </section>

        <section>
            <h3 id="move-copy-delete">Move, Copy and Delete Semantics</h3>
            <p>

            </p>
        </section>

        <section>
            <h3 id="namespace-registry">Namespace Registry</h3>
            <p>
                The repository provides access to the <a>namespace registry</a> containing a mapping of
                <a>prefixes</a> to their corresponding <a>namespace IRI</a>.
            </p>
            <section>
                <h4>Default Mappings</h4>
                <p>
                    Repositories contain at least following mappings:
                </p>
                <table class="simple">
                    <thead>
                        <tr>
                            <th>Namespace Prefix</th>
                            <th>Namespace <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>hmf</td>
                            <td>http://hmf.org/ns/hmf/1.0</td>
                            <td>Reserved for <a>items</a> defined within in core <abbr
                                    title="Hierarchical Metadata Framework">HMF</abbr> <a>types</a>
                            </td>
                        </tr>
                    </tbody>
                    <tbody>
                        <tr>
                            <td>mix</td>
                            <td>http://hmf.org/ns/mix/1.0</td>
                            <td>Reserved for the <a>names</a> of built-in <a>mixin</a> <a>node</a> <a>types</a>.
                            </td>
                        </tr>
                    </tbody>
                    <tbody>
                        <tr>
                            <td><em>the empty string</em></td>
                            <td><em>the empty string</em></td>
                            <td>The default namespace is the <em><a>empty namespace</a></em>.
                            </td>
                        </tr>
                    </tbody>
                </table>

            </section>

            <section>
                <h4 id="empty-namespace">Empty Namespace</h4>
                <p>
                    The <a>empty namespace</a> is a permanent and immutable member of the <a>namespace registry</a>
                    which can be used for default data or when <a>namespaces</a> are not required, such as for
                    trivial
                    or single domain metadata storage applications.
                </p>
            </section>
        </section>
        <section>
            <h3 id="custom-value-types">Custom Value Types</h4>
                <section>
                    <h4>Defining Custom Types</h4>
                    <p></p>
                </section>
                <section>
                    <h4>Custom Value Type Registry</h4>
                    <p>

                    </p>
                </section>
        </section>
        <section>
            <h3 id="observation">Observation</h4>

        </section>
    </section>

    <section class="informative">
        <h2>Indexing</h2>
        <p>
            Indexing is a core consideration of storage and repository implementations, however it's not
            considered a part of the HMF core model specification.
        </p>
    </section>

    <section class="informative">
        <h2>Internationalization Considerations</h2>
        <p>Storing internationlized strings... </p>
    </section>

    <section class="informative">
        <h2>Relationship to RDF</h2>
    </section>

    <section class="appendix informative">
        <h2>Built-in Type Definitions</h2>
    </section>

</body>

</html>