<!DOCTYPE html>
<html>

<!--
    Editorial notes:
    * Anchors are used for terms only the first time it's used within a section. This is 
      to avoid extensive and noisy hyperlink which might be overburdening for the reader. 

    Todos:
    * Complete terms list 
    * Formally define the namespace registry?
    * Remove versioned reference? might be unnecessary given that version is referenceable
-->

<head>
    <meta charset="utf-8" />
    <title>Hierarchical Metadata Framework - Core Model v1.0</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
    <script src="../common/common.js" class="remove" defer></script>
    <script class="remove">
        // All config options at https://respec.org/docs/
        var respecConfig = {
            localBiblio: {
                "RDFStar": {
                    "title": "RDF-star and SPARQL-star",
                    "authors": [
                        "Olaf Hartig",
                        "Pierre-Antoine Champin"
                    ],
                    "publisher": "W3C",
                    "status": "W3C CG Draft",
                    "href": "https://w3c.github.io/rdf-star/cg-spec/2021-02-18.html",
                    "editors": ["Olaf Hartig", "Pierre-Antoine Champin"],
                    "date": "2021-02-18"
                },
                "json-ld-star": {
                    "title": "JSON-LD Star",
                    "editors": [
                        "Gregg Kellogg",
                    ],
                    "href": "https://json-ld.github.io/json-ld-star/",
                }
            },
            shortName: "HMF Model",
            specStatus: "base",
            noRecTrack: true,
            authors: [{
                name: "Paul Wilson"
            }, {
                name: "Dave Clark"
            }],
            editors: [{
                name: "Paul Wilson"
            }, {
                name: "Dave Clark"
            }],
            xref: "web-platform",
            latestVersion: null,
            subtitle: "An abstract model for hierarchical graph metadata",
        };
    </script>
    <style src="../common/style.css" type="text/css"></style>
    <style type="text/css">
        .illustration {
            text-align: center;
        }
    </style>
</head>

<body>
    <p class="copyright">Copyright...</p>
    <section id="abstract">
        <p>
            This specification describes the Hierarchical Metadata Framework (HMF) core model, a standard model and
            framework for hierarchical & linked metadata. HMF addresses many aspects of metadata
            representation including domain modelling, versioning, identity & location, navigation, namespacing,
            reasoning, reification and so on. HMF serves as the foundation for applications dealing with
            the metadata trees and graphs at the heart of modern web and media organisations.
        </p>
        <p>
            HMF is a framework encompassing both the storage and representation of hierarchical metadata as well
            as the semantics of operations over that metadata. This specification therefore must be complimented
            by a concrete document syntax for the serialization of metadata and a repository implementation providing
            the APIs for those operations.
        </p>
        <p>
            HMF takes inspiration from a variety of specifications including [[[JSON-LD11]]], [[[RDF-CONCEPTS]]],
            [[[XML]]] and <a
                href="https://developer.adobe.com/experience-manager/reference-materials/spec/jcr/2.0/index.html">Content
                Repository for Java Technology API Specification (JSR-283)</a>.
        </p>

    </section>
    <section id="sotd" class="override">
        <h2>Status of this Document</h2>
        <p>This document is in Draft state.</p>

    </section>
    <section class="normative">
        <h2>Terminology & Conventions</h2>
        <section>
            <h3>Terminology</h3>
            <div data-include="../common/terms.html" data-oninclude="restrictReferences"></div>
        </section>

        <section class="normative">
            <h3>Diagram Conventions</h3>
            <p>
                This specification uses diagrams consisting of the following elements
                to clarify concepts within the model:
            </p>
            <table class="simple" style="width:100%">
                <thead>
                    <tr>
                        <th>Element</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><img src="node-convention.png" alt="Node" width="110" /></td>
                        <td>Illustrates a regular <a>node</a>.</td>
                    </tr>
                    <tr>
                        <td><img src="typed-node-convention.png" alt="Node" width="110" /></td>
                        <td>Illustrates a <a>node</a> including its <a>primary type</a> in compact form</td>
                    </tr>
                    <tr>
                        <td><img src="version-convention.png" alt="Node" width="110" /></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><img src="node-type-convention.png" alt="Node" width="110" /></td>
                        <td></td>
                    </tr>
                </tbody>
            </table>
        </section>
    </section>
    <section class="information">
        <h1 id="introduction">Introduction</h1>
        <p>
            <abbr title="Hierarchical Metadata Framework">HMF</abbr> is a framework for hierarchical metadata. It
            provides a foundation for organising, querying, inferencing, change-tracking and administering the metadata
            trees and graphs that lie at the heart of modern web and media organisations. <abbr
                title="Hierarchical Metadata Framework">HMF</abbr> was conceived as a foundation for
            <em>media-content</em> curation and syndication, but was designed to be agnostic to any domain where
            metadata is <em>primarily hierarchical</em>.
        </p>
        <p>
            HMF implements <em>linked-data</em> (as described in [[[linked-data]]]) and uses <cite><a class="bibref"
                    data-link-type="biblio" href="#bib-rdf11-concepts"
                    title="RDF 1.1 Concepts and Abstract Syntax"><abbr
                        title="Resource Definition Framework">RDF</abbr></a></cite> as a <a
                data-cite="rdf11-mt#dfn-semantic-extension">base model and notation</a> but extends it with
            certain conditions and restrictions that make it suitable for hierarchical metadata representation.
            In doing so, HMF benefits from the model-theoretic semantics of RDF and the semantic web in general. It also
            allows HMF to take advantage of the various serialization vocabularies such as [[[JSON-LD11]]].
            HMF&apos;s relationship to RDF is explored in section [[[#relationship-to-rdf]]].
        </p>
        <p>
            <abbr title="Hierarchical Metadata Framework">HMF</abbr> allows for information to be captured and
            formalized within the model through <a>types</a>. Types categorise, characterise and constrain metadata and
            so serve as building blocks for robust applications. Types can be applied to metadata at <em>any
                point during its lifecycle</em> allowing for raw and unstructured data to be edited and reasoned into
            formalised, semantically rich trees.
        </p>
        <hr />
        <p>
            By focusing on domains where metadata is organised primarily into hierarchies,
            <abbr title="Hierarchical Metadata Framework">HMF</abbr> supports a rich set of semantics that
            would be otherwise unavailable:
            <dl>
                <dt>Move, Copy & Delete</dt>
                <dd>Move, copy & delete operations applied on a <a>node</a> apply to the their entire <a>subtree</a>.
                    This is conceptually identical to copying files and folders on a filesystem and allows metadata to
                    be organised and managed whilst preserving structure.</dd>
                <dt>Child Node Constraints</dt>
                <dd>HMF allows <a>child node type definitions</a> to dictate which child-types are permitted on a
                    <a>node</a>. Using child node constraints, we can build metadata trees with <em>strong
                        guarantees</em> about the validity of both data and structure.
                </dd>
                <dt>Cascading Access Control</dt>
                <dd>Permissions and access control directives can be applied to <a>nodes</a> and to all
                    descendents in a <em>cascading</em> fashion. Much like a filesystem, user or group principals
                    therefore can own and administer entire <a>subtrees</a> without the overhead of
                    permission-management of every node.
                </dd>
                <dt>Tree Versioning</dt>
                <dd>When a specific version of a <a>node</a> is tracked, it is often desirable to also track its
                    subtree. HMF allows subtrees of a <a>versionable</a> <a>node</a> to be automatically tracked when
                    the owning <a>versionable</a> <a>node</a> is checked-in.
                </dd>
                <dt>Location & Navigation</dt>
                <dd><a>Trees</a> give <a>nodes</a> and <a>properties</a> a <em>location</em> as defined by its
                    <a>path</a> relative to the metadata <a>root</a>. This means information not only has
                    <a>identity</a> but also <a>location</a> allowing for metadata to be discovered or accessed relative
                    to other metadata via the process of <a>navigation</a>. <a>Navigation</a> allows knowledge to be
                    <em>explored</em> without prior information about what is available or even the structure of the
                    metadata tree.</dd>
            </dl>
        </p>
        <hr />
        <p>
            This document provides the <em>abstract</em> model for <abbr
                title="Hierarchical Metadata Framework">HMF</abbr>, defining structure and semantics
            independent of any particular document representation, encoding or concrete syntax. This separation allows
            for concrete vocabularies to be defined external to this document each providing their own model
            representation for metadata interchange and delivery.
        </p>
        <section class="informative">
            <h2 id="key-concepts">Key Concepts</h2>
            <section>
                <h3 id="hybrid-data-model">Hybrid Hierarchical-Graph Model</h3>
                <p>
                    <abbr title="Hierarchical Metadata">HMF</abbr> provides a modelling framework
                    for metadata that fits naturally into a <a>tree</a> of <a>nodes</a>. The <a>tree</a>
                    structure is convenient for organising information in such a way that related
                    metadata can be explored, located, access controled, constrained, versioned,
                    moved or deleted easily.
                </p>
                <p>
                    <a>Trees</a> model sets of <em>one-to-many</em> relationships as a <em>directed acyclic graph</em>.
                    Although fine for some applications it's unlikely to be adequate for non-trivial metadata domains.
                    <abbr title="Hierarchical Metadata">HMF</abbr> therefore allows <a>nodes</a> to reference
                    arbitrary <a>nodes</a> irrespective of whether they share an ancestry. This allows for
                    <em>many-to-many</em> relationships to be modelled within <abbr
                        title="Hierarchical Metadata">HMF</abbr>.
                </p>
                <div class="illustration">
                    <p><img src="hybrid-graph.png" alt="Hybrid Graph Hierarchical Model" width="400" /></p>
                    <p class="caption">Shows the hybrid graph-hierarchical model by illustrating
                        a <a>tree</a> with <a>parent-child relationships</a> for containment
                        and <a>reference relationships</a> for arbitrary <a>node</a> connections.
                        </a></p>
                </div>
                <p>
                    Overall the data model is similar to a filesystem which consists of folders containing files
                    which may be traversed using a file<a>path</a>, and symbolic links to connect subtrees. The major
                    difference is that in a filesystem only the leaf nodes hold data, whereas in HMF all <a>nodes</a>
                    may contain <a>properties</a> however some may not have any <a>child nodes</a>.
                </p>
            </section>
            <section>
                <h3 id="namespaces">Namespaces</h3>
                <p>
                    <a>Namespaces</a> separate data belonging to different domains or arriving from different
                    sources into well-defined, recognisable and distinguishable groupings referenced using an
                    <abbr title="Internationalized Resource Identifier">IRI</abbr>. In <abbr
                        title="Hierarchical Metadata">HMF</abbr> both <a>nodes</a> and <a>properties</a>
                    are namespaced, meaning that structural and value elements of the model exist not only
                    within the <a>tree</a> but also within a <a>namespace</a>.
                </p>
                <div class="illustration">
                    <p><img src="namespaces.png" alt="Nodes and Properties Occupying Namespaces" width="600" /></p>
                    <p class="caption">Illustrates a <a>tree</a> where <a>nodes</a> and <a>properties</a>
                        reside across two distinct <a>namespaces</a> (<code>ns1</code> & <code>ns2</code>).
                    </p>
                </div>
                <p>
                    Namespaces are yet another tool to subdivide and <a>tree</a> metadata into meaningful
                    scopes or groupings. Typically this is to prevent naming collisions across common metadata
                    that is controlled or owned by different parties. It could also be used to represent
                    different <em>dimensions</em> or <em>planes</em> of metadata such that different namespace-
                    specific <abbr title="User Interface">UI</abbr> views or plugins can be activated.
                </p>
            </section>
            <section>
                <h2>Types & Domain Modelling</h2>
                <p>
                    <a>Types</a> in <abbr title="Hierarchical Metadata Framework">HMF</abbr> provide the means
                    to <em>represent knowledge</em> within the sytem through <a>formalisms</a> about a given domain
                    within the metadata model. HMF is unique in that types are themselves <em>first-class
                        metadata</em> within the model. Types may be dynamically applied and modified without
                    compromising the integrity of the metadata <a>trees</a> they formalise.
                </p>
                <p>
                    The dynamic nature of types makes HMF ideally suited to applications where metadata is
                    modified and matured within the system until it is ready for export or delivery. Metadata
                    may arrive in a raw and unstructured form and have types progressively applied
                    until meeting the preconditions for a downstream system. HMF allows
                    a <a>node</a> or <a>tree</a> to be evaluated in terms of types, and then for that type
                    to be applied.
                </p>
                <p>
                    Types categorise and constrain both values (i.e. held within <a>properties</a>) as well as
                    the hierarchical structure of a <a>tree</a>. By enforcing that a <a>node</a> and its descendents
                    have specific <a>node</a> types, HMF can make <em>strong guarantees</em> about what clients
                    can expect as they traverse and <a>tree</a> hierarchy and its data.
                </p>
            </section>
            <section>
                <h2 id="versioning-intro">Versioning</h2>

                <p>
                    HMF&apos;s versioning capability allows the state of a <a>node</a> and its <a>versionable
                        subtree</a> to be
                    recorded and later accessed, restored or referenced. Versioning is key for editorial scenarios
                    where metadata changes may need to be reverted, or a record of modifications is needed for
                    auditing purposes. Also the ability have a <a>node</a> hold a <a>reference</a> to a version
                    of another <a>node</a> means it can guarantee the state of the referenced node and its immutability.
                </p>
                <div class="illustration">
                    <p><img src="versioning-introduction.png" alt="Node Versioning & Version Storage" width="600" /></p>
                    <p class="caption">A <a>node</a> with versions (<code>v1,v2,v3</code>) available in <a>version
                            storage</a>
                    </p>
                </div>
                <p>
                    Versions in HMF provide a snapshot of the state of a <a>node</a> and its <a>versionable subtree</a>
                    in much the same way that a version control system holds the historical state of the filesystem.
                    In HMF, version histories are linear changesets and the standard model does not provide the means
                    to branch and merge version histories in the same way that modern version control systems can. That
                    is, versioning in HMF is a means to track historical state; it is not the basis for a branch-based
                    editorial workflow.
                </p>

            </section>
            <section>
                <h2 id="annotations-intro">Annotations</h2>

                <p>
                    <a>Annotations</a> address the problem of how to capture additional information about
                    the <a>properties</a> and <a>relationships</a> of a <a>node</a>. For example, a
                    <a>node</a> may contain a <a>property</a> named <code>title</code> with a value,
                    however we may want to record additional information such as certainty scores, weights,
                    temporal restrictions, permissions and provenance information. Annotations solve
                    this by providing <a>properties</a> <em>about <a>properties</a> or <a>relationships</a></em>.
                </p>
                <p>
                    The following illustration shows an <a>annotation</a> property capturing additional information
                    about the <code>title</code> <a>property</a>, specifically the timestamp of when the data was
                    <code>provided</code>. We might also choose to store which data source provided this property or
                    when the information is due to expire or need reviewing:
                </p>

                <div class="illustration">
                    <p><img src="annotation-example.png" alt="Property Annotation" width="600" /></p>
                    <p class="caption">Annotation of a Property</p>
                </div>

                <p>
                    An <a>annotation</a> can also be applied to a <a>relationship</a> to capture additional
                    information about the relation, such as the expected type of the referred <a>node</a>.
                    An annotation may contain a reference to another <a>node</a> offering a way to
                    indirectly link <a>nodes</a> to both <a>properties</a>and child <a>relationships</a>.
                    Annotations are versioned along with the <a>node</a> so that the annotated state is
                    captured alongside checked-in <a>node</a> state.
                </p>
            </section>
        </section>
    </section>
    <section>
        <h2 id="representation">Tree Primitives</h2>
        <section class="informative">
            <h3>Introduction</h3>
            <p>
                Core to the HMF standard model is the concept of a <a>tree</a> consisting of a graph
                of <a>items</a>. The term <a>item</a> refers to both <a>nodes</a> and <a>properties</a>
                which together provide the primitives for representing the <em>values</em> and <em>structure</em>
                of metadata. All <a>items</a> are said to have a <a>location</a> which can be represented
                using a <a>path</a> (see [[[#paths]]]).
            </p>
        </section>
        <section>
            <h3 id="entities">Entities &amp; Identity</h3>
            <p>
                The term <a>entity</a> refers to anything in the metadata <a>tree</a> that has an <a>identity</a>
                and may be referenced using an IRI <em>indepedently from its <a>location</a> in the <a>tree</a></em>.
                <a>Referenceable nodes</a> are <a>entities</a> since they hold the <code>hmf:referenceable</code>
                property containing a UUID which may be resolved (see [[[#referenceable-type]]]). Notably,
                <a>properties</a> are not <a>entities</a> since they must be referenced in the context of a <a>node</a>
                or <a>located</a> using a <a>path</a>.
            </p>
            <p>
                <a>Entities</a> allow clients and external systems to hold a fixed identifier in the form
                of an IRI that is guaranteed to resolve to <em>the same entity</em> throughout its lifecycle.
                Notably, a <a>property</a> or a non-<a>referenceable node</a> fails this condition since it
                may only be resolved using a <a>path</a> which will break if that property or non-referenceable node
                is moved.
            </p>
            <p>
                The following qualify as <a>entities</a>:
                <dl data-sort>
                    <dt> referenceable nodes</dt>
                    <dd> <a>Nodes</a> possessing the type <code>mix:referenceable</code> contain a UUID which may be
                        used to dereference the node using a <a>identifier segment</a></dd>
                    <dt> namespace registry</dt>
                    <dd> The <a>namespace registry</a> is guaranteed to be available with a fixed identity as provided
                        by the <a>repository node</a></dd>
                    <dt> version histories</dt>
                    <dd> <a>Version histories</a> are themselves <a>referenceable</a> and can be referenced in the same
                        way as <a>referenceable nodes</a></dd>
                    <dt> versions</dt>
                    <dd> <a>Versions</a> are themselves <a>referenceable</a> and can be referenced in the same way as
                        <a>referenceable nodes</a></dd>
                    <dt> repository node</dt>
                    <dd> The repository node has a fixed identity throughout the lifetime of the <a>repository</a> </dd>
                    <dt> types</dt>
                    <dd> Types have a fixed <a>name</a> that is guaranteed to persist</dd>

                </dl>
            </p>
        </section>
        <section>
            <h3 id="resources">Resources</h3>
            <p>
                A <a>resource</a> is anything in the metadata <a>tree</a> that can be referenced using an IRI including
                <a>items</a> which may be located using a <a>path</a> or by following <a>references</a>. All
                <a>entities</a> are resources.
            </p>
            <div class="illustration">
                <p><img src="resource-entity-venn.png" alt="Nodes" width="400" /></p>
                <p class="caption">Illustrates the set of <a>resource</a> types along with those which are also
                    <a>entities</a> within HMF</p>
            </div>
        </section>
        <section>
            <h3 id="nodes">Nodes</h3>
            <section class="informative">
                <h4>Introduction</h4>
                <p>
                    <a>Nodes</a> are typed containers of <a>properties</a> and <a>child nodes</a> that provide the
                    structure to data held within HMF. It is through <a>nodes</a> that hierarchies are formed with
                    one <a>node</a> able to act as a <em>parent</em> or <em>container</em> for other <a>nodes</a>.
                </p>
                <p>
                    Nodes have <a>names</a> (see [[[#names]]]) which identify them among their siblings and are used
                    as <a>segments</a> in <a>paths</a> (see [[[#path-segments]]]). <a>Referenceable nodes</a> also have
                    a universally unique <a>identity</a> encoded as an IRI (see [[[#node-identity]]]) allowing a node to
                    be resolved independently of its <a>location</a>. A capability that is discussed in
                    [[[#referenceable-type]]].
                </p>
                <p>
                    <a>Nodes</a> have a single <i>parent</i> relationship to their <i>parent</i> <a>node</a> (except
                    for the <a>root node</a>, see [[[#root-node]]]), and zero-or-more <i>child</i> <a>nodes</a>.
                    These parent-child relationships form an acyclic graph (formally referred to as a <a>tree</a>)
                    holding the primary structure of the metadata. All <a>nodes</a> are connected to all other nodes
                    via parent-child relationships, if only via the <a>root node</a>.
                </p>
                <p>
                    A <i>child</i> is affected by its parent and ancestors in various ways. For example, <i>move</i>,
                    <i>copy</i> and <i>delete</i> operations on a <a>node</a> will recursively copy the <a>node</a>'s
                    descendents (see [[[#move-copy-delete]]]). Permissions applied within a <a>repository</a> to a
                    parent will <i>cascade</i> to descendents. The versioning strategy applied to a <a>node</a> will
                    govern the <i>read-only</i> status of a child when the parent is checked-in (see [[[#versioning]]]).
                </p>
                <div class="illustration">
                    <p><img src="hmf-nodes.png" alt="Nodes" width="400" /></p>
                    <p class="caption">Nodes with parent and child relationships</p>
                </div>
                <p>
                    <a>Nodes</a> also act as a container for <a>properties</a> as described in [[[#properties]]].
                    All <a>nodes</a> carry a small set of mandatory properties (see [[[#mandatory-properties]]]).
                </p>
                <p>
                    <a>Nodes</a> have a <a>type</a> (see [[[#node-types]]]) which defines the core characteristics
                    of the node. Nodes have a single <a>primary type</a> and zero or more <a>mixin types</a> which
                    together define what properties and child nodes are required or permitted on the name, and their
                    respective types. Nodes have an <em>is-a</em> relationship with each of its types.
                </p>
                <p>
                    One interesting characteristic of node <a>types</a> is that they can declare child nodes and
                    properties to be <em>auto-created</em>. That is, if no value is supplied during creation,
                    the system will create the property or child node with default values. This is useful to
                    eleviate the user from having to pre-create all mandatory child-nodes explicitly when the
                    parent node is created. It can also provide users with example sub-trees ready for modification.
                    See [[[#auto-creation]]].
                </p>
            </section>

            <section>
                <h3 id="node-names">Node Names</h3>
                <p>
                    Each <a>node</a> has a <a>name</a> used to locate the <a>node</a> among its siblings. The
                    <a>node</a> <a>name</a> is used within <a>paths</a> to allow <a>nodes</a> to be located without
                    knowing their <a>identity</a>. See [[[#names]]] for a full description of <a>names</a>.
                </p>
                <p>
                    Names allow all <a>nodes</a> to be resolved irrespective of whether they are <a>referenceable
                        nodes</a>. This is because names can be used in <a>segments</a> to construct a <a>path</a>
                    which may be <a>traversed</a> to <a>locate</a> a given node.
                </p>
                <p class="note">
                    Allowing all <a>resources</a> to be resolved using an <a>IRI</a> allows HMF to maintain
                    compatibility with RDF. An <a>IRI</a> that relies on <a>location</a>
                    has different semantics to those that rely on <a>identity</a>. Holders of a <a>location IRI</a>
                    must be aware that the <a>referent</a> <a>resource</a> is not permanent and may resolve to a
                    <a>resource</a> with a different <a>identity</a>. THis is in contrast to <a>identity IRIs</a>
                    where holders are guaranteed to always resolve to the same <a>entity</a> unless it has been
                    deleted.
                </p>
            </section>

            <section>
                <h3 id="node-identity">Node Identity</h3>
                <p>
                    Relying on a <a>path</a> to locate a <a>node</a> could be problematic when we consider that
                    <a>nodes</a> can be moved. In cases where a <a>node</a> must be retrievable irrespective of
                    its location in the hierarchy, we may rely instead on <a>node identity</a>.
                </p>
                <p>
                    A <a>node</a> that can be retrieved using its <a>identity</a> is said to be <a>referenceable</a>.
                    Storage systems would typically use an index to quickly locate a <a>referenceable</a>
                    <a>node</a> within a <a>repository</a>. Maintaining such an index incurs a cost in terms of
                    resources
                    and performance as it would need to be stored and maintained within the storage system. It
                    becomes therefore a <i>design choice</i> as to whether a given node should be <a>referenceable</a>.
                </p>
                <p>
                    <a>Nodes</a> can be related to one another via <a>references</a> as described in
                    [[[#references]]].
                    <a>Node</a> <a>identity</a> is used to support <a>references</a> as only <a>nodes</a>
                    that are <a>referenceable</a> can be referred to from a <a>node</a>. Note that this restriction
                    does not apply to <a>parent-child relationships</a> where either node can be non-referenceable.
                </p>
                <p>
                    If a given <a>node</a> has the <i>mixin type</i> (see [[[#primary-mixin-types]]]) of
                    <code>mixin:referenceable</code> then the <a>node</a> is <a>referenceable</a>.
                    <a>Referenceable</a> <a>nodes</a> acquire the <a>property</a>
                    <code>hmf:uuid</code> from the <code>mixin:referenceable</code> type which holds a universally
                    unique <a>repository</a>-managed identifier.
                    This identifier may be used outside of a <a>repository</a> to reference the <a>node</a> and
                    acts as the <a>value</a> of <a>reference</a> <a>properties</a> (see [[[#references]]]).
                </p>
            </section>
            <section>
                <h3 id="root-node">Root Node</h3>
                <p>
                    The <a>root node</a> is the only <a>node</a> in the <a>working tree</a> without a parent node.
                    The root node has the type <code>hmf:system</code> and can always be <a>located</a> using the
                    <a>path</a> <code>/</code>. The <a>root node</a> is considered <a>protected</a> and cannot be
                    modified, moved or deleted.
                </p>
            </section>
            <section>
                <h3 id="mandatory-properties">Mandatory Properties</h3>
                <p>
                    All <a>nodes</a> contain the following mandatory <a>properties</a>:
                    <table class="simple">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>hmf:primaryType</code></td>
                                <td><code>type:string</code></td>
                                <td>The <a>compact IRI</a> of a <a>node</a>'s primary type (see
                                    [[[#primary-mixin-types]]])
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </p>
            </section>
            <section>
                <h3 id="primary-mixin-types">Primary & Mixin Types</h3>
                <p>
                    All <a>nodes</a> have a <a>primary type</a> and zero or more <a>mixin types</a>. These types
                    are combined into an <a>effective type</a> as described in [[[#effective-node-type]]].
                    A <a>node</a> has an <em>is-a relationship</em> with each of its <a>types</a>.
                    See [[[#types]]].
                </p>
            </section>
        </section>


        <section>
            <h2 id="properties">Properties</h2>
            <section class="informative">
                <h3>Introduction</h3>
                <p>
                    <a>Properties</a> belong to <a>nodes</a> and hold the <i>data</i> or <a>values</a> associated with
                    that <a>node</a>. A <a>property</a> consists of a <a>name</a> as defined in [[[#names]]] and zero
                    or more <a>values</a> of a specific <a>value type</a>.
                </p>
                <p>
                    The <a>type</a> of a <a>property</a> determines the range of <a>values</a> it can store and is
                    defined by a <a>datatype IRI</a> (see [[[#property-required-type]]]). It is not possible to modify
                    the <a>type</a> of a <a>property</a>.
                </p>
                <p class="note">
                    HMF presently does not support the registration of new <a>value types</a> for <a>properties</a>
                    as this could introduces dependencies and incompatibilies between a <a>document</a> and a
                    <a>repository</a>. By enforcing a fixed set of <a>value types</a> we ensure that all repositories
                    can represent all <a>documents</a>.
                </p>
                <p>
                    <a>Properties</a> may impose further restrictions on their values beyond those implied by their
                    <a>value type</a> using <a>value constraints</a>. This might be a <em>regular expression</em>
                    over a string property or a min-max restriction on a long or date property.
                </p>
            </section>
            <section>
                <h3 id="mult-value-properties">Multi-value Properties</h3>
                <p class="ednote" title="Much of this is duplicated but may still be needed?">
                    These sections need some considered. What are we trying to achieve here? And introduction to
                    properties or a formal definition? Since the property type definition section already covers a
                    lot of this.
                </p>
                <p>
                    Properties can either be <em>single-valued</em> or <em>multi-valued</em>.
                </p>
                <p>
                    A single-value property, if it exists, must have a value. There is no such thing as a <em>null</em>
                    value. A multi-value property can have zero or more values. Again there is no such thing as a null
                    value, however a multi-value property can be empty, just as an array can be empty.
                </p>
                <p>
                    Whether a particular property is a multi-valued property is governed by the property definition
                    applicable to it, which is determined by the node type of the property's parent node (see
                    [[[#node-types]]]).
                </p>
                <section>
                    <h4 id="property-array-semantics">Array Semantics</h4>
                    <p>
                        The values stored within a multi-valued property are all of the same type. A multi-valued
                        property by default has <em>array</em> semantics. That is, they are <em>ordered</em> and may
                        contain <em>duplicate</em> values.
                    </p>
                </section>
                <section>
                    <h4 id="property-set-semantics">Set Semantics</h4>
                    <p>
                        A multi-value property can be declared to have <em>set</em> semantics. In this case, the
                        property will only every contain unique values and there will be no defined ordering.
                    </p>
                </section>
            </section>
            <section>
                <h3 id="value-constraints">Value Constraints</h3>
                <p>
                    <a>Value constraints</a> are specified on a <a>property type definition</a> and control the
                    range of values available to a specific property. See [[[#property-value-constraints]]]
                    for a full discussion.
                </p>
            </section>
        </section>

        <section>
            <h2 id="working tree">Working Tree</h2>
            <p>
                The <a>working tree</a> refers to the main <em>active</em> <a>tree</a> holding the current state
                of the metadata against which modifications should be made. This is in contrast to <a>version
                    storage</a> which holds historical state.
            </p>
        </section>

        <section>
            <h2 id="names">Names &amp; Namespaces</h2>
            <p>
                <a>Names</a> in <abbr title="Hierarchical Metadata Framework">HMF</abbr> are conceptually the same as
                <a>names</a> in [[XML]]. They consist of a <a>namespace IRI</a> (or the empty string in the case of
                [[[#empty-namespace]]]) and a <a>local name</a>, and are written in their expanded form as
                <code>{NAMESPACE}LOCAL_NAME</code>, for example: <code>{http://hmf.org/ns/hmf/1.0}primaryType</code>.
            </p>
            <p>
                <code>NAMESPACE</code> is either the empty string <code>""</code> or a <a>namespace IRI</a> that
                identifies the <a>namespace</a> and must be <em>registered</em> within the <a>namespace
                    registry</a>before it is used.
            </p>
            <p>
                <a>Namespaces</a> are <em>registered</em> along with a <a>prefix</a> allowing <a>names</a> to be
                written in their <em>compact</em> form; <code>PREFIX:LOCAL_NAME</code>, for example:
                <code>hmf:primaryType</code>. The registration of the <a>namespace</a> takes places with the
                <a>namespace registry</a>.
            </p>
            <p>
                The compact form of a <a>name</a> is commonly used, however a namespace mapping of <a>prefixes</a>
                to <a>namespace IRIs</a> must be supplied.
            </p>
            <p>
                <div class="note">
                    <p>
                        [[XML]] and [[RDF-CONCEPTS]] both use resource identifiers within their naming scheme but in
                        subtly different ways. In [[XML]] a name is an <em>ordered pair</em> consisting of a
                        <a>namespace IRI</a> and a <a>local name</a> which is commonly written in the form
                        <a>namespace</a>:<a>local name</a> (known as a <a
                            data-cite="REC-xml-names#dt-qualname">QName</a>). A <a>namespace IRI</a> must be formally
                        <em>declared</em> before its corresponding <a>prefix</a> may be used and there is no formal
                        <em>expanded form</em> of a <a data-cite="REC-xml-names#dt-qualname">QName</a>.
                    </p>
                    <p>In contrast, [[RDF-CONCEPTS]] states that subjects are represented with an IRI which can be
                        conveniently written as a <a>compact IRI</a> in the form <a>prefix</a>:<em>suffix</em>. In
                        [[RDF-CONCEPTS]], this <a>compact IRI</a> can be expanded via simple concatentation to reveal
                        the subject IRI, with no deterministic way to return to the <a>compact IRI</a> form.
                    </p>
                    <p> The absence of a formal definition of namespaces in [[RDF-CONCEPTS]] means that a document could
                        contain overlapping prefixes where different <a>compact IRIs</a> expand to the same IRI during
                        concatenation, thus mangling their namespaces.
                    </p>
                    <p>
                        The distinction boils down to <em>scoping</em>. In [[RDF-CONCEPTS]] resources are identified
                        with <em>globally scoped</em> IRIs and there is an expectation that work has been done to
                        carefully select an IRI structure that is globally unique and suitable for the <em>semantic
                            web</em>. In contrast, [[XML]] is a document interchange format where careful namespacing
                        consideration cannot be presupposed of the data it represents and as such, names are
                        explicitly <em>scoped into a namespace</em> during serialization.
                    </p>
                    <p>
                        <abbr title="Hierarchical Metadata Framework">HMF</abbr> chooses to follow [[XML]] by defining a
                        <a>name</a> as an ordered pair and provides a <a>namespace registry</a> to map <a>prefixes</a>
                        to their <a>namespace IRIs</a>. The result is that all <a>names</a> belong to a specific
                        <a>namespace</a>. This is the more appropriate choice for the representation and interchange
                        of metadata trees and graphs within organizations where careful namespacing cannot be
                        presupposed.
                    </p>
                </div>
            </p>
            <section>
                <h3>Local Name</h3>
                <p>
                    The local name identifies the <a>item</a> within the containing <a>node</a> with respect to the
                    <a>namespace</a>. For example, the <a>name</a> <code>acme:title</code> holds the local name
                    <code>title</code>.
                </p>
            </section>
            <section>
                <h3>Naming Restrictions</h3>
                <p>
                    HMF does not support the following characters in localnames: <code>/</code>,
                    <code>:</code><code>[</code><code>]</code><code>|</code><code>*</code> since they
                    have alternate meanings typically due to lexical forms of <a>paths</a> or in
                    <a>residual definitions</a>.
                    <ul>
                        <li><em>forward slash <code>/</code></em> - this is used as a <a>segment</a> separate in the
                            lexical form of <a>paths</a></li>
                        <li><em>colon <code>:</code></em> - used to separate the <a>prefix</a> and <a>local name</a>
                            within a <a>name</a></li>
                        <li><em>open square bracket <code>[</code></em> - used to signal a <a>identifier segment</a>
                            within the
                            lexical form of a <a>path</a></li>
                        <li><em>close square bracket <code>]</code></em> - used to signal a <a>identifier segment</a>
                            within the
                            lexical form of a <a>path</a></li>
                        <li><em>pipe <code>|</code></em> - reserved for future use</li>
                        <li><em>asterisk <code>*</code></em> - used in <a>residual definitions</a></li>
                    </ul>
                </p>
                <p>

                    HMF does not offer guidance on how to treat similar names with different code points which may be
                    the cause of potential security issues.
                </p>
            </section>

            <section>
                <h3 id="empty-namespace">The Empty Namespace</h3>
                <p>
                    For trivial or single-source metadata applications, enforcing a <a>namespace</a> could be overly
                    burdensome. <abbr title="Hierarchical Metadata Framework">HMF</abbr> provides a permanent <a>default
                        namespace</a> with prefix <code>""</code> (i.e. the empty string), also referred to as the
                    <a>empty namespace</a>. This allows <a>names</a> to omit the <a>prefix</a> and be located using
                    their
                    <a>local name</a> only.
                </p>
            </section>
        </section>

        <section>
            <h2 id="annotations">Annotations</h2>
            <p>
                Annotations capture additional metadata about node&quot;s <a>properties</a> and relationships. For each
                <a>item</a> of a <a>node</a> we can access its <a>annotation</a> which is itself a collection of
                properties. Annotation properties can be of any type available to regular properties, however these
                properties are themselves not annotatable.
            </p>
            <p>
                <a>Nodes</a> that have the <a>mixin</a> type <code>mix:annotated</code> are said to be
                <em>annotated</em>. It's only possible to access annotations on nodes with this <a>mixin</a>
                type. The means for accessing annotations are implementation specific.
            </p>
            <p>
                <div class="note">
                    <p>The two popular graph-based data models have been RDF [[RDF11-CONCEPTS]] and
                        <a href="https://en.wikipedia.org/wiki/Graph_database#Labeled-property_graph">Labeled-property
                            Graphs</a>,
                        which are roughly similar, with the RDF model being more formal in identifying <a>nodes</a>,
                        datatypes and relationships, while Property Graphs
                        use a less formal relationship model somewhat similar to JSON. In both models,
                        nodes are related via edges (AKA arcs), but in Property Graphs,
                        those edges may themselves be annotated with properties.
                        This is useful in providing additional metadata and semantics to relationships
                        of the <a>nodes</a>.
                    </p>
                    <p>
                        <abbr title="Hierarchical Metadata Framework">HMF</abbr> takes a hybrid approach
                        by providing an RDF-style model that uses IRIs to formally identify <a>entities</a> whilst
                        allowing node properties and relationships to be annotated with additional metadata
                        as with labeled property graphs (LPGs).
                    </p>
                </div>
            </p>
            <p>
                Annotations are considered as part of a <a>node</a>&quot;s <a>versionable tree</a>.
                It is not currently possible to enforce mandatory annotations or any other property
                type declarations on annotation properties.
            </p>
            <section>
                <h3>Standard Annotations</h3>
                <p>
                    The following annotations enable functionality in HMF.
                </p>

                <table class="simple">
                    <thead>
                        <tr>
                            <th>Type <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>hmf:versionLabel</code></td>
                            <td>
                                Used to annotate <a>reference types</a> with a specific version label. When
                                the annotation reference property is resolved to a <a>node</a>, the version of
                                that <a>node</a> with the <a>version label</a> provided in this annotation
                                should be retrieved. It is assumed that the target node of the reference has the
                                <a>mixin</a> type <code>mix:versionable</code>. See [[[#versioned-reference]]].
                            </td>
                        </tr>
                        <tr>
                            <td><code>hmf:ordering</code></td>
                            <td>
                                Indicates whether the annotated multi-value property is <em>ordered</em> or
                                <em>un-ordered</em>. If the annotation has the value <code>list</code> then
                                the multi-value property is ordered. If the annotation has the value <code>set</code>
                                then the multi-value property is unordered. This annotation provides additional
                                semantics allowing clients to interpret a multi-value property appropriately.
                                If the annotated property is single-valued then this annotation is redundant.
                            </td>
                        </tr>
                    </tbody>
                </table>
                <p class="ednote" title="Ordering should be part of the type not the node">
                    We need to move the ordering to the property type definition.
                </p>

            </section>
        </section>
        <section>
            <h2 id="auto-creation">Auto-creation</h2>
            <p>
                HMF allows for the <em>recursive</em> creation of <a>properties</a> and <a>child nodes</a> upon the
                creation of a parent <a>node</a>. These auto-created <a>items</a> are created with a default value
                as defined in the <a>item definition</a>. Auto-creation allows for entire <a>trees</a> to be
                created and is especially useful for conveniently creating mandatory and default values.
            </p>
        </section>
    </section>

    <section>
        <h2>Relationships &amp; Navigation</h2>
        <section class="informative">
            <h2>Introduction</h2>
            <p>
                HMF supports <em>type types</em> of relationships, <a>parent-child relationships</a> and <a>reference
                    relationships</a>. Parent-child relationships organise metadata into a structure that allows
                <a>items</a> to be <a>located</a> using <a>paths</a>.
            </p>
            <p>
                Parent-child relationships are bidirectional connections between a node and its child. These
                relationship are more than just associations, they imply that parent <em>contains</em> its child nodes
                or that child nodes <em>belong to</em> their parent. This containment or ownership relationship is
                transitive meaning that operations on a node can affect all descendents. For example, a delete
                (see [[[#move-copy-delete]]]) operation on a <a>node</a> is recursive and will delete all its child
                nodes and the child nodes of their child nodes, and so on.
            </p>
            <p>
                Reference relationships are a unidirectional connections between two arbitrary node. Reference
                relationships do not imply any <em>containment</em> relationship.
            </p>
        </section>
        <section>
            <h2>Relationships</h2>
            <section>
                <h3 id="parent-child-relationships">Parent-Child Relationships</h3>
                <p class="ednote" title="NEEDS WORK">
                    This section needs some editing and refinement.
                </p>
                <p>
                    <abbr title="Hierarchical Metadata Framework">HMF</abbr> has <i>first-class</i> support for
                    <i>parent-child</i> relationships between <a>nodes</a>. Parent-child relationships have additional
                    semantics beyond what are provided for regular [[[#references]]]. For example, a child is considered
                    to belong to its parent, meaning that re-locating the parent also relocates the child. Versioning a
                    parent in many cases will also version the child. A parent's <a>type</a> may also enforce that it
                    has a child with a given <a>name</a> and <a>type</a>.
                </p>
                <p>
                    Parent-child relationships can be said to define the <a>tree</a> structure metadata.
                    They are bi-directional.
                </p>
                <p>
                    <a>Trees</a> allow <a>paths</a> to be used to locate a <a>node</a>. <a>Paths</a> can only
                    be used to traverse <em>parent-child</em> relationships and do not apply to <a>references</a>.
                    <a>Nodes</a> can be referenced either using their identity or using their location as defined
                    by their <a>path</a> from the <a>root</a> to the <a>node</a>.
                </p>
                <p>
                    <a>Primary item</a> allows clients to navigate through parent-child relationships without
                    knowing the names of the intermediate
                </p>
                <p>
                    First class support in type system (types can declare child types)
                </p>
                <p>
                    <abbr title="Hierarchical Metadata Framework">HMF</abbr> does not support <a>same name siblings</a>.
                    That is, all children of a node must have a unique name.
                </p>
                <p>
                    No cycles - that is, a parent cannot have a child that is in its ancestor list.
                </p>
            </section>
            <section>
                <h3 id="references">Reference Properties</h3>
                <p>
                    In contrast to <a>parent-child relationships</a>, <a>reference relationships</a> may connect
                    arbitrary <a>nodes</a>. Reference relationships do not imply any further relationship between
                    the connected nodes (such as containment with <a>parent-child relationships</a>) and may create
                    cycles. The <a>referent</a> (the <a>node</a> being referenced) must have the type
                    <code>mix:referenceable</code>.
                </p>
                <section>
                    <h3 id="referenceable-type">Referenceable Type - <code>mix:referenceable</code></h3>
                    <p>
                        A <a>node</a> may only be the target of a <a>reference property</a> if it has the type
                        <code>mix:referenceable</code>. This node type adds an auto-created, mandatory,
                        <code>type:string</code>
                        property to the <a>node</a>, called <code>hmf:uuid</code>, which exposes the identifier of the
                        node.
                        The identifier is a UUID and not an IRI.
                    </p>
                </section>
                <section>
                    <h4 id="strong-weak-references">Referential Integrity</h4>
                    <p>
                        A given <a>property</a> of type <code>type:reference</code> with value <code>V</code>, there
                        must exist a <a>node</a> within the metadata <a>tree</a> (either <a>working tree</a> or
                        <a>version storage</a>) with <code>hmf:uuid</code> as <code>V</code>.
                    </p>
                    <p>
                        So such restriction applies to <a>properties</a> of type <code>type:weakreference</code>.
                    </p>
                    <p>
                        The repository must therefore ensure that during creation of a <a>property</a> of type
                        <code>type:reference</code> that the target <a>node</a> exists and must not allow the deletion
                        of <a>nodes</a> that are the target of such <em>strong references</em>.
                    </p>
                </section>
                <section>
                    <h4 id="versioned-references">Versioned References</h4>
                    <p>
                        <a>Versioned references</a> allow a <a>property</a> to hold a reference to a specific version
                        <em>label</em> of a <a>node</a>, guaranteeing that the reference resolves to an immutable and
                        known node state. This is a key building block for systems where a <em>stable</em> or
                        <em>promoted</em> version of a <a>node</a> must be referenced whilst simultaneously edited,
                        and versions are maintained using their label.
                    </p>
                    <p class="note">
                        It is possible to hold a direct reference to a <a>version</a>.
                    </p>
                    <p>
                        <div class="illustration">
                            <p><img src="versioned-reference.png"
                                    alt="Annotation Specifying the Label of a Versioned Reference" width="700" /></p>
                            <p class="caption">Annotation Specifying the Label of a <a>Versioned Reference</a></p>
                        </div>
                    </p>
                    <p>
                        The annotation <code>hmf:versionLabel</code> should contain the <a>version label</a> of the
                        desired version. Clearly the target node should have the <a>mixin</a> type
                        <code>mix:versionable</code>.
                    </p>
                </section>

            </section>
            <section>
                <h3 id="primary-item">Primary Item</h3>
                <p>
                    A <a>node type</a> can declare <em>one</em> of its <a>item definitions</a> as primary, meaning that
                    for all <a>nodes</a> of that type, that <a>item</a> is accessible in a way that does not require the
                    name of the item. Primary item allow clients to traverse a <a>tree</a> without upfront knowledge of
                    the <a>node</a> structure.
                </p>
                <p>
                    A client could for example know to traverse a <a>tree</a>&quot;s primary item until a
                    <a>node</a> of a given <a>type</a> or <a>name</a> is encountered. This would allow editors to modify
                    a <a>tree</a>&quot;s structure, perhaps be adding or removing intermediate nodes, without breaking
                    the client.
                </p>
            </section>
        </section>
        <h2 id="paths">Paths</h2>
        <p>
            A HMF path allows an <a>item</a> to be resolved in terms of its <em>location</em> within the <a>tree</a>
            rather than its <em>identity</em>. In some scenarios, <em>location</em> is preferred over <a>identity</a>
            because resolution needs to happen with respect to a <a>node</a>&quot;s position relative to another
            <a>node</a>
            (including the <a>root</a>).
        </p>
        <section>
            <h3 id="path-segments">Path Segments</h3>
            <p>
                Paths are an ordered list of path <a>segments</a> <em>S = (P0,P1,...,PN)</em> of which there are the
                following types:
                <ul>
                    <li>A compact name segment with the <a>name</a> in its <a>prefix</a> form, such as
                        <code>acme:episode</code></li>
                    <li>An expanded name segment with the <a>name</a> in its expanded form, such as
                        <code>{http://acme.org/ns/}episode</code></li>
                    <li>the identifier segment where a <a>node</a> is identified by its identity</li>
                    <li>the versioned identifier segment where a version of a <em>versionable</em> node is identified
                        using the identity of its base version and a version <em>label</em></li>
                    <li>the versioned name segment where a version of a <em>versionable</em> node is identified
                        using its <a>name</a> and a version <em>label</em></li>
                    <li>the root segment which identifies the <a>root</a> node</li>
                    <li>the self segment which identifies the contextual node</li>
                    <li>the parent segment which identifies the parent <a>node</a> of the contextual node</li>
                </ul>
            </p>
            <p>
                The <em>root</em>, <em>self</em> and <em>parent</em> segments are constants with intuitive
                lexical forms as described in [[[#path-lexical-form]]].
            </p>
        </section>
        <section>
            <h4 id="segment-types">Segment Types</h4>

            <dl class="termlist" data-sort>
                <dt>
                    <dfn data-lt="compact name segments" class="preserve">compact name segment</dfn></dt>
                <dd>The <a>compact name segment</a> uses the <a>item</a> <a>name</a> in its <a>compact IRI</a> form.
                    That is, the segment consists of <a>prefix</a> and <a>local name</a> separated by a colon
                    (<code>:</code>). For example, <code>acme:title</code>.
                </dd>
                <dt>
                    <dfn data-lt="expanded name segments" class="preserve">expanded name segment</dfn></dt>
                <dd>The <a>expanded name segment</a> uses the namespace and <a>local name</a> in their expanded form.
                    That is, the segment consists of <a>namespace IRI</a> enclosed in braces <code>{}</code> and
                    the <a>local name</a>. For example, <code>{http://acme.org/ns}title</code> </dd>
                <dt>
                    <dfn data-lt="versioned name segments" class="preserve">versioned name segments</dfn></dt>
                <dd>The <a>versioned name segment</a> includes a name followed a version label enclosed in square
                    brackets <code>[]</code>. For example, <code>acme:title[version1]</code> or
                    <code>{http://acme.org/ns}title[version1]</code>
                </dd>
                <dt>
                    <dfn data-lt="identifier segments" class="preserve">identifier segment</dfn></dt>
                <dd>The <a>identifier segment</a> identifies a <a>node</a> using its unique identifer enclosed in
                    square brackets. For example, <code>[208a03d6-bb81-11ec-8422-0242ac120002]</code>.</dd>
                <dt>
                    <dfn data-lt="versioned identifier segments" class="preserve">versioned identifier segment</dfn>
                </dt>
                <dd>The <a>versioned identifier segment</a> combines the <a>identifier segments</a> with a version
                    label.
                    It therefore consists of the identifier enclosed in square brackets <code>[]</code> followed
                    by the version label in square brackets <code>[]</code>.
                    For example, <code>[208a03d6-bb81-11ec-8422-0242ac120002][version1]</code></dd>
                <dt>
                    <dfn data-lt="root segments" class="preserve">root segment</dfn></dt>
                <dd>The <a>root segment</a> identifies the root of the repository. It is identified as the absence of
                    a value.
                </dd>
                <dt>
                    <dfn data-lt="self segments" class="preserve">self segment</dfn>
                </dt>
                <dd>The <a>self segment</a> identifies the context node. It takes the form of a single period:
                    <code>.</code>.
                </dd>
                <dt>
                    <dfn data-lt="parent segment" class="preserve">parent segment</dfn></dt>
                <dd> The <a>parent segment</a> identifies the parent of the context node. It takes the form of two
                    periods:
                    <code>..</code>.
                </dd>
            </dl>
        </section>
        <section>
            <h4>Relative Paths & Context Nodes</h4>
            <p>
                Relative paths start with the <a>self segment</a>.
            </p>
        </section>


        <section>
            <h3 id="path-lexical-form">Lexical Form</h3>
            <p>

            </p>
        </section>
        <section>
            <h3 id="traversal">Path Traversal</h3>
            <p>
                Intermediate nodes may not exist due to permission restrictions
            </p>
        </section>
    </section>

    <section>
        <h2 id="types">Types</h2>
        <section class="informative">
            <h3>Introduction</h3>
            <p>
                Types are a fundamental and foundational component of <abbr
                    title="Hierarchical Metadata Framework">HMF</abbr>
                since they are the means for <em>domain knowledge</em> to be formalised within the model.
                Types capture the characterstics and structure of a given metadata model and offer strong
                guarantees about the data it holds.
            </p>
            <p>
                Types provide a <em>classification</em> to <a>nodes</a> and <a>properties</a>. This classification
                indicates the range of possible values that can be held and in the case of <a>nodes</a>, the
                types of child <a>nodes</a> it may posses. ...
            </p>
            <p>
                In HMF there are three types of type definition:
                <ul>
                    <li><em>Node Type Definition</em> - defines a node type within the model including which primary
                        types in inherits from, which <a>mixin</a> types it carries, whether it declares a <a>primary
                            item</a> and so on. It also acts as a container for <a>property type definitions</a> and
                        <a>child node type definitions</a>.</li>
                    <li><em>Property Type Definition</em> - defines the type and contraints of a <a>property</a>
                        including its value type, whether it is single-valued or multi-values, whether it is
                        mandatory and so on.
                    </li>
                    <li><em>Child Node Type Definition</em> - defines the type and constraints of a child node
                        including its primary types, whether the child node is mandatory and details of how the
                        child node should be auto-created if needed.</li>
                </ul>
            </p>

            <div class="illustration">
                <img src="node-type-def.png" alt="Node Type Definition" width="600" />
                <p class="caption">Shows a <a>node type definition</a> with the <a>name</a> <code>acme:content</code>.
                    It declares two <a>properties</a> via two <a>property type definitions</a> for
                    <code>acme:title</code>
                    and <code>acme:genres</code>, along with a <a>residual</a> <a>child node definition</a> declaring
                    that all child <a>nodes</a> of this <a>type</a> must be of the type <code>acme:show</code>.
                </p>
            </div>

            <p>
                Node types may be dynamically modified within an application assuming the changes are compatible
                with all <a>nodes</a> of that type. For example, a new <em>non-mandatory</em> field or a
                mandatory field with a default value may be added to a node type. If a node type applies further
                restrictions, then all <a>nodes</a> with that type must first conform to those restrictions before
                the modification will be allowed.
            </p>
            <p>
                Node types may be dynamically applied <a>nodes</a> within a <a>tree</a>. This means that once a
                node conforms to a given type, that type may be applied as its primary type or <em>mixed-in</em>
                to that node. This allows editorial pipelines to be constructed where additional types are added
                to metadata as it matures through the system.
            </p>
        </section>

        <section class="informative">
            <h3 id="node-types">Node Types</h3>
            <section>
                <h4 id="primary-type">Node Primary Type</h4>
                <p>
                    Every <a>node</a> has a single declared primary type. Nodes have an <em>is-a</em> relationship
                    with the primary type. The primary type of a node typically defines the core characteristics of the
                    node in the domain model. This is in contrast to mixin nodes which add additional and supplimentary
                    functionality or metadata.
                </p>
                <p>Given that primary types may inherit from one another, a node can be said to have multiple types
                    or formally, multiple <a>supertypes</a>. Implementations should provide the means for clients to
                    acquire all supertypes of a node.
                </p>
                <p>
                    The default primary type of a node is <code>hmf:base</code> (see [[[#builtin-primary-types]]]).
                </p>
            </section>
            <section>
                <h4>Mixin Types</h4>
                <p>
                    A <a>node</a> may have zero or more <a>mixin types</a>. Mixin types provide a way to compose
                    functionality or key metadata (such as standardized metadata, see [[[#builtin-mixins]]])
                    on a node. They are used to mark nodes as eligible for some model or repository feature such as
                    <code>mix:annotated</code> (see [[[#annotations]]]) and <code>mix:versionable</code> (see
                    [[[#versioning]]]).
                </p>
                <p>
                    Mixin types may not be used as a primary type of a node, however they can be used as supertypes
                    of primary types. Only mixin types may be supertypes of mixin types.
                </p>
            </section>
            <section>
                <h4 id="node-type-inheritance">Node Type Inheritance</h4>
                <p>
                    Both <a>primary types</a> and <a>mixin types</a> can take advantage of inheritance which allows a
                    <a>node type</a> to inherit from a <a>supertype</a> or parent <a>node type definition</a>.
                    Subtypes inherit the parent property and child node type definitions, including any such definitions
                    themselves inherited from the parent&quot;s supertype. The resulting definition known as the
                    <a>effective node type</a> is the sum of all inherited type definitions.
                </p>
                <p>
                    When a <a>node type</a> <code>T<sub>sub</sub></code> in inherits from a <a>supertype</a>
                    <code>T<sub>super</sub></code> it recieves the <a>item definitions</a> from
                    <code>T<sub>super</sub></code>. In the majority of cases those <a>item definitions</a> are
                    <em>added</em> to those already defined on <code>T<sub>sub</sub></code>. If a given
                    definition <code>D<sub>sub</sub></code> has the same <a>name</a> and classification (i.e.
                    node or property type definition) as a definition <code>D<sub>super</sub></code> on
                    <code>T<sub>super</sub></code> then <code>D<sub>sub</sub></code> overrides
                    <code>D<sub>super</sub></code>. <a>Residual definitions</a> are always added.
                </p>

            </section>
            <section>
                <h4 id="multiple-inheritance">Multiple Inheritance</h4>
                <p>
                    HMF allows for a <a>node type</a> to be defined with multiple <a>supertypes</a> irrespective of
                    whether those <a>supertypes</a> are <a>primary types</a> or <a>mixin types</a>. When a
                    <a>node type</a> is declared it may therefore specify a set of <a>supertypes</a>.
                </p>
                <p>
                    If a given subtype <a>node type definition</a> <code>T<sub>sub</sub></code> inherits from
                    a given supertype <a>node type definition</a> <code>T<sub>super</sub></code> then:
                    <ul>
                        <li>
                            If <code>T<sub>super</sub></code> is a <a>mixin type</a> then <code>T<sub>sub</sub></code>
                            may be a <a>mixin type</a> or <a>primary type</a>.
                        </li>
                        <li>
                            If <code>T<sub>super</sub></code> is a <a>primary type</a> then <code>T<sub>sub</sub></code>
                            must also be a <a>primary type</a>.
                        </li>
                    </ul>
                </p>
            </section>
            <section>
                <h4>Updating the Primary Type</h4>
                <p>
                    The <a>primary type</a> of a node may be modified after node creation. This is a key capability
                    of HMF since it allows for progressive typing during the lifecycle of a metadata <a>tree</a>.
                    The primary type of a node may only be changed if all mandatory <a>items</a> are already present
                    on that node.
                </p>
            </section>
        </section>
        <section>
            <h3 id="node-type-definition">Node Type Definition</h3>
            <p>

            </p>
            <section>
                <h4>Name</h4>
                <p>
                    Every node type registered with the repository has a unique <a>name</a>. The naming conventions for
                    node types are the same as for items and are described in [[[#names]]].
                </p>
            </section>
            <section>
                <h4>Version</h4>
                <p>
                    Provides a version identifier (typically as an incrementing integer) for the node type.
                </p>
            </section>
            <section>
                <h4>Supertypes</h4>
                <p>
                    A primary node type (with the exception of <code>hmf:base</code>) must extend another node type (and
                    may extend more than one node type). A <a>mixin</a> node type may extend another node type.
                </p>
            </section>
            <section>
                <h4>Is Abstract</h4>
                <p>
                    A node type may be declared abstract, meaning that it cannot be assigned as the primary or mixin
                    node type of a node but can be used in the definition of other node types as a supertype.
                    Abstract node types are therefore used to define common types that do not themselves function
                    as a standalone node type.
                </p>
            </section>
            <section>
                <h4>Is Mixin</h4>
                <p>
                    A node type may be declared as either a <a>mixin type</a> or a <a>primary node type</a>.
                    If it is declared as a <a>mixin type</a> then it may not be used as a primary type of a
                    node however a primary type may inherit from a mixin type.
                </p>
            </section>
            <section>
                <h4>Primary Item</h4>
                <p>
                    A node type may specify one child item (property or node) by name as the primary item. A primary
                    item is an item on a node that is considered <em>primary</em> or <em>default</em>, and may be
                    accessed from the declaring node without requiring the <a>name</a>. Primary items are commonly
                    used to allow clients to navigate through intervening until they reach a node of the desired
                    type.
                </p>
            </section>
            <section>
                <h4>Property Type Definitions</h4>
                <p>
                    A node type typically (although not always) declares one or more <a>property type definitions</a>
                    controlling which properties are restricted or permitted.
                </p>
            </section>
            <section>
                <h4>Child Node Type Definitions</h4>
                <p>
                    A node type typically (although not always) declares one or more <a>child node type definitions</a>
                    controllnig which child nodes are restricted or permitted.
                </p>
            </section>
            <section>
                <h4>Node Type Documentation</h4>
                <p>
                    A <code>hmf:documentation</code> property may be added to a node type definition containing a
                    <code>type:string</code> value.
                </p>
            </section>
        </section>
        <section>
            <h3 id="property-type-definition">Property Definition</h3>
            <p>
                A <a>property definition</a> on a node controls the behaviour of a <a>property</a> and the <a>values</a>
                it may contain. A <a>property definition</a> may declare the following:
                <ul>
                    <li><em>Name</em> - The <a>name</a> of the <a>property</a> to which this definition
                        applies, or <code>*</code> if this definition is a <a>residual definition</a>, meaning that it
                        applies to any additional properties with any names apart from those otherwise defined in this
                        node type (see [[[#residual-definition]]]).</li>
                    <li><em>Required type</em> - defines the datatype of the value held by the <a>property</a></li>
                    <li><em>Value constraints - The value constraints on the property define the range of values that
                            may be assigned to this property.</em></li>
                    <li><em>Default value</em> - The value that the property will have if it is auto-created.</li>
                    <li><em>Auto-created status</em> - Whether this property will be auto-created when its parent node
                        is created. Only properties with a default value can be auto-created.</li>
                    <li><em>Mandatory status</em> - A mandatory property is one that must exist. If a node of a type
                        that specifies a mandatory property is created then any attempt to save that node without adding
                        the mandatory property will fail. Since single-value properties either have a value or do not
                        exist (there being no concept of the <code>null</code> value) this implies that a mandatory
                        single-value property must have a value. A mandatory multi-value property on the other hand may
                        have zero or more values.</li>
                    <li><em>Mutliple values status</em> - Whether this property can have multiple values, meaning that
                        it stores an array of values, not just one.
                    </li>
                    <li><em>Multiple values semantics status</em> - If the property contains multiple values,
                        determines if the property has <em>list</em> or <em>set</em> semantics. List semantics
                        indicates that the values are ordered. Set semantics indicates that the values are not ordered.
                    </li>
                    <li><em>On-Parent-Version status</em> - The On-Parent-Version status of specifies what happens to
                        this property if a new version of its parent node is created (i.e. a checked-in is done on it).
                    </li>
                    <li><em>Description</em> - Provides a narrative description of the property.</li>

                </ul>
            </p>
            <section>
                <h4>Name</h4>
                <p>
                    The <a>name</a> of the <a>property</a> to which this definition
                    applies, or <code>*</code> if this definition is a <a>residual definition</a>, meaning that it
                    applies to any additional properties with any names apart from those otherwise defined in this
                    node type (see [[[#residual-definition]]]).
                </p>
            </section>
            <section>
                <h4 id="residual-property-definition">Residual Property Definition</h4>
                <p>
                    When the <a>name</a> attribute of the node type definition is <code>*</code> (asterisk),
                    it specifies that the definition is <a>residual</a>, meaning that its scope consists of all other
                    properties
                    (child nodes), which are not otherwise scoped by any of the other property (child node) definitions
                    in the effective node type of the node (see [[[#effective-node-type]]]).
                </p>
            </section>
            <section>
                <h4 id="property-required-type">Standard Required Types</h4>
                <p>
                    The following <i>standard</i> required types are defined, although a <a>repository</a> may choose to
                    support additional <a>types</a>:
                    <table class="simple">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Datatype <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>string</td>
                                <td><code>type:string</code></td>
                                <td>A sequence of characters encoded as UTF-8</td>
                            </tr>
                            <tr>
                                <td>boolean</td>
                                <td><code>type:boolean</code></td>
                                <td>The value of <code>true</code> or <code>false</code></td>
                            </tr>
                            <tr>
                                <td>long</td>
                                <td><code>type:long</code></td>
                                <td>An integer with a minimum value of -2<sup>63</sup> and a maximum value of
                                    2^<sup>63-1</sup>.
                                </td>
                            </tr>
                            <tr>
                                <td>double</td>
                                <td><code>type:double</code></td>
                                <td>A double-precision 64-bit IEEE 754 floating point.
                                </td>
                            </tr>
                            <tr>
                                <td>decimal</td>
                                <td><code>type:decimal</code></td>
                                <td>...</td>
                            </tr>
                            <tr>
                                <td>date</td>
                                <td><code>type:date</code></td>
                                <td>An [[ISO8601]] date</td>
                            </tr>
                            <tr>
                                <td>weakreference</td>
                                <td><code>type:weakreference</code></td>
                                <td>An identifer to a referenceable node <i>without</i> enforced referential
                                    integrity.
                                </td>
                            </tr>
                            <tr>
                                <td>reference</td>
                                <td><code>type:reference</code></td>
                                <td>An identifer to a referenceable node <i>with</i> enforced referential integrity.
                                </td>
                            </tr>
                            <tr>
                                <td>uri</td>
                                <td><code>type:uri</code></td>
                                <td>A sequence of characters that conform to [[RFC3987]]</td>
                            </tr>
                            <tr>
                                <td>path</td>
                                <td><code>type:path</code></td>
                                <td>A <a>path</a> in either <a>absolute</a> or <a>relative</a> form represented in
                                    its
                                    lexical (string) form</td>
                            </tr>
                            <tr>
                                <td>undefined</td>
                                <td><code>type:undefined</code></td>
                                <td>A special type indicating that there is no required type. This is only used
                                    in type declarations and all properties in the <a>tree</a> must have
                                    one of the other available types. <code>type:undefined</code> is commonly used
                                    in <a>residual definitions</a>, see [[[#residual-property-definition]]]
                                    and [[[#residual-child-node-definition]]].</td>
                            </tr>
                        </tbody>
                    </table>
                </p>
            </section>
            <section>
                <h3 id="property-value-constraints">Values Constraints</h3>
                <p>
                    Value constraints limit the range of possible values that a property can hold. They are
                    an extension to the restrictions enforced by the value type (see [[[#property-required-type]]])
                    and allow for further modelling of the metadata domain.
                </p>
                <section>
                    <h4><code>type:string</code> Constraints</h4>
                    <p>Constraints on <code>type:string</code> are expressed as <em>regular expressions</em>. The
                        exact implementation of regular expression used is implementation specific.</p>
                </section>
                <section>
                    <h4>Numeric Type Constraints</h4>
                    <p>Types <code>type:long</code>, <code>type:decimal</code>, <code>type:double</code> and
                        <code>type:date</code> may be subject to <em>numerical</em> constraints limiting
                        the range of possible values available. This is achieved using a comma separated
                        pair including an <em>upper</em> and <em>lower</em> bound in the form enclosed in either
                        a square bracket <code>[]</code> or parenthesis <code>()</code>. The square brackets
                        <code>[]</code> indicate inclusivity and the parenthesis <code>()</code> indicate
                        exclusivity.
                    </p>
                    <p>
                        Some examples:
                        <ul>
                            <li><code>[0,100]</code> - an <em>inclusive</em> range permitting the integers
                                <code>0</code> to <code>100</code></li>
                            <li><code>(0,100)</code> - an <em>exclusive</em> range permitting the integers
                                <code>1</code> to <code>99</code></li>
                            <li><code>[1649627836,]</code> - this indicates any value <code>1649627836</code>
                                or greater. If this was a date then it would represent any date on or after
                                <em>Sunday, 10 April 2022 22:57:16 GMT+01:00</em>.</li>
                            <li><code>[200,500)</code> - an <em>inclusive floor</em> and <em>exclusive ceiling</em>
                                permitting integers in the range <code>200</code> to <code>499</code></li>
                            <li><code>[,500)</code> - any integer up to <code>499</code></li>
                        </ul>
                    </p>
                </section>
                <section>
                    <h4><code>type:path</code> Constraints</h4>
                    <p>Path constraints can either prescribe a specific allowed path or an allowed ancestor if
                        terminating in <code>/*</code>. These constraints allow the model to enforce that a
                        property can only refer to specific paths or subpaths.
                    </p>
                    <p>
                        Some examples:
                        <ul>
                            <li><code>/path/to/node</code> - the path must be equal to this value</li>
                            <li><code>/path/to/ancestor/*</code> - the path must start with
                                <code>/path/to/ancestor</code></li>
                        </ul>
                    </p>
                </section>

            </section>
            <section>
                <h3 id="default-values-property">Default Values</h3>
                <p>
                    The default value of a property is the value assigned to a property if it is auto-created
                    (see [[[#auto-created-property]]]). This may be a single value or multiple values depending
                    on the [[[#single-multi-value-properties]]]. The default value must have the same value type
                    as the property it is defined on.
                </p>
            </section>
            <section>
                <h3 id="auto-created-property">Auto-created Values</h3>
                <p>
                    A property may be declared <em>auto-created</em>, meaning that it is automatically created upon
                    creation of its parent <a>node</a> or the moment that the property becomes part of a node&apos;s
                    type (as may be the case with <a>mixin types</a>). If no value is supplied during <a>node</a>
                    creation then the default value is used (see [[[#default-values-property]]]). Auto-created values
                    are especially useful when adding mandatory properties to node types and for supplying default
                    values.
                </p>
                <p>
                    <div class="note">
                        Properties may be auto-created if the node implicitly acquires the property from one
                        of its <a>supertypes</a> or if a <a>mixin</a> type is added to a node type. For example,
                        adding <code>mix:created</code> implies the addition of <code>hmf:created</code> and
                        <code>hmf:createdBy</code> which should be
                    </div>
                </p>
            </section>
            <section>
                <h4 id="mandatory-properties">Mandatory status</h4>
                <p>
                    A property may be marked as <em>mandatory</em>. If the property is single-valued then a
                    value must be present for that property and there is no <code>null</code> value. If the
                    property is multi-valued it may have zero or more values. If a <a>node</a> defines a
                    property that single-valued and mandatory then it must be supplied during node-creation
                    otherwise an error is raised.
                </p>
            </section>
            <section>
                <h4 id="single-multi-value-properties">Mutliple values status</h4>
                <p>
                    Whether this property can have multiple values, meaning that
                    it stores an array of values, not just one. See [[[#single-multi-value-properties]]].
                </p>
            </section>
            <section>
                <h4>Collection semantics</h4>
                <p>
                    If the property contains multiple values, determines if the property has <em>list</em> or
                    <em>set</em> semantics. List semantics indicates that the values are ordered. Set semantics
                    indicates that the values are not ordered. See [[[#single-multi-value-properties]]].
                </p>
            </section>
            <section>
                <h4>On-Parent-Version status</h4>
                <p>
                    The On-Parent-Version (OPV) status of specifies what happens to this property if a new version of
                    its parent node is created (i.e. a checked-in is done on it). See [[[#on-parent-version]]].
                </p>
            </section>
            <section>
                <h3 id="protected-property">Protected Properties</h3>
                <p>
                    Protected properties are properties that are managed by the implementation and
                    cannot be modified by clients. Protected properties are read-only by clients and
                    read-write for implementations.
                </p>
            </section>
            <section>
                <h4>Description</h4>
                <p>
                    Holds a narrative description of the <a>property</a>.
                </p>
            </section>
        </section>
        <section>
            <h3 id="child-node-definition">Child Node Definition</h3>
            <p>
                <a>Child node definitions</a> are used to specify the characteristics of the <a>child nodes</a> allowed
                on <a>nodes</a> with a given <a>type</a>. They control the <a>names</a>, <a>types</a>,
                <a>on-parent-version</a> behaviour and so on. They are the means through which structural restrictions
                are enforced on a <a>tree</a>.
            </p>
            <p>
                A <a>child node definitions</a> may also state that the child node must be <em>auto-created</em>.
                Auto-creation behaves recursively allowing entire metadata <a>trees</a> to be created with just the
                creation of a single ancestor node.
            </p>
            <p class="note">
                Note that there is no equivalent definition controlling <a>reference</a> relationships.
            </p>
            <section>
                <h4>Name</h4>
                <p>
                    The <a>name</a> of the child node to which this definition applies or the wildcard <code>*</code> if
                    this definition is a <a>residual definition</a>, meaning that it applies to any additional child
                    nodes with any names apart from those otherwise defined in this node type (see
                    [[[#residual-child-node-definition]]]).
                </p>
            </section>
            <section>
                <h4 id="residual-child-node-definition">Residual Child Node Definition</h4>
                <p>
                    When the <a>name</a> attribute of the node type definition is <code>*</code> (asterisk),
                    it specifies that the definition is <a>residual</a>, meaning that its scope consists of all other
                    child nodes, which are not otherwise scoped by any of the other child node definitions in the
                    effective node type of the node (see [[[#effective-node-type]]]).
                </p>
            </section>
            <section>
                <h4>Required primary types</h4>
                <p>
                    If it specifies only a single node type <code>N</code> then the primary node type of this child node
                    must be <code>N</code> or a subtype of <code>N</code>. If this attribute specifies multiple node
                    types
                    <code>N<sub>1</sub></code>, <code>N<sub>2</sub></code>,<code>...</code>, <code>N<sub>M</sub></code>
                    then the primary node type of this child node must be a subtype of all the types
                    <code>N<sub>1</sub></code>, <code>N<sub>2</sub></code>,  <code>N<sub>M</sub></code>.
                    See [[[#multiple-inheritance]]] for a discussion of type inheritance and subtyping rules.
                </p>
            </section>
            <section>
                <h4>Default primary type</h4>
                <p>
                    This is the primary node type automatically assigned if no node type information is specified when
                    the node is created.
                </p>
            </section>
            <section>
                <h4>Auto-create status</h4>
                <p>
                    Governs whether this child node will be auto-created when its parent node is created.
                </p>
            </section>
            <section>
                <h4>Mandatory status</h4>
                <p>
                    Governs whether the child node is mandatory. A mandatory child node is one that must exist. If a
                    mandatory child node is missing from a parent node then save on the parent node will fail.
                </p>
            </section>
            <section>
                <h4>On-Parent-Version status</h4>
                <p>
                    This specifies what to do with the child node if its parent node is versioned. See See
                    [[[#on-parent-version]]].
                </p>
            </section>
        </section>
        <section>
            <h3 id="effective-node-type">Effective Node Type</h3>
            <p>
                The <a>effective node type</a> of <a>node</a> </a><code>N</code>is the resulting <a>type</a> once all
                <a>item definitions</a> from all <a>supertypes</a> have been inherited and applied subject to the
                inheritance rules. It is therefore the sum of all <a>item definitions</a>:
                <ul>
                    <li>declared in the <a>primary type</a> of <code>N</code></li>
                    <li>inherited by the <a>primary type</a> of <code>N</code></li>
                    <li>declared in the <a>mixin types</a> of <code>N</code></li>
                    <li>inherited by the <a>mixin types</a> of <code>N</code></li>
                </ul>
            </p>
        </section>
        <section>
            <h3 id="residual-definition">Residual Definitions</h3>
            <p>
                A <a>residual definition</a> is an unnamed <a>item definition</a> that applies to all other <a>items</a>
                that are not otherwise scoped and defined by any of the other <a>item definition</a> present on the
                <a>effective type</a> of a <a>node</a>.
            </p>
            <p>
                Residual definitions are marked by having the wildcard <a>name</a> (<code>*</code>).
            </p>
        </section>
        <section>
            <h3>Builtin Types</h3>
            <section>
                <h4 id="builtin-primary-types">Builtin Primary Types</h4>
                <p>

                </p>
                <table class="simple">
                    <thead>
                        <tr>
                            <th>Type <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>hmf:base</code></td>
                            <td>
                                This is the base type of all primary node types and therefore all nodes in a
                                HMF model. It exposes the mandatory property <code>hmf:primaryType</code>
                                and the optional property <code>hmf:mixinTypes</code>. This is the only
                                type in the model that does not itself extend another type.
                            </td>
                        </tr>
                        <tr>
                            <td><code>hmf:versionHistory</code></td>
                            <td>
                                Holds the <a>version history</a> of a <a>node</a> in the <a>working tree</a>.
                                It acts as the parent of all <a>version nodes</a> of a <a>versionable node</a>
                                and holds the <a>version labels</a> for the various <a>versions</a>.
                            </td>
                        </tr>
                        <tr>
                            <td><code>hmf:version</code></td>
                            <td>
                                Holds metadata about a <a>version node</a> including the date that it was
                                created and the sets of ancestor and predecessor nodes. The version node
                                also contains the <a>frozen node</a> holding the snapshot-state of the
                                <a>versionable node</a> for this version. See [[[#version-metadata]]].
                            </td>
                        </tr>
                        <tr>
                            <td><code>hmf:frozenNode</code></td>
                            <td>
                                Holds a copy of the <a>versionable node</a> in version storage. It also
                                holds copies of the core metadata in the properties <code>hmf:frozenPrimaryType</code>,
                                <code>hmf:frozenMixinTypes</code> and <code>hmf:frozenUuid</code> (as not to collide
                                with the properties already held on <code>hmf:frozenNode</code>). See
                                [[[#version-metadata]]].
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <section>
                <h4 id="builtin-mixins">Builtin Mixin Types</h4>
                <table class="simple">
                    <thead>
                        <tr>
                            <th>Type <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>mix:created</code></td>
                            <td>
                                Used to add standardized information about the creation of the node via the
                                properties
                                <code>hmf:created</code> (providing the timestamp that the node was created) and
                                <code>hmf:createdBy</code> (providing the principal that created the node).
                                In cases where the <a>mixin</a> is applied to an already created node, these
                                properties
                                must be auto-created with values as-determined by the implementation.
                            </td>
                        </tr>
                        <tr>
                            <td><code>mix:modified</code></td>
                            <td>
                                Used to add standardized information about the modification of the node via the
                                properties
                                <code>hmf:modified</code> (providing the timestamp that the node was modified) and
                                <code>hmf:modified</code> (providing the principal that modified the node).
                                In cases where the <a>mixin</a> is applied to an already created node, these
                                properties
                                must be auto-created.
                            </td>
                        </tr>
                        <tr>
                            <td><code>mix:versionable</code></td>
                            <td>
                                Indicates that the <a>node</a> is subject to versioning. See [[[#versioning]]].
                            </td>
                        </tr>
                        <tr>
                            <td><code>mix:annotated</code></td>
                            <td>
                                Indicates that the <a>node</a> carries annotations. See [[[#annotations]]]
                            </td>
                        </tr>
                        <tr>
                            <td><code>mix:referenceable</code></td>
                            <td>
                                Indicates that the <a>node</a> may be the subject of a <a>reference</a>. See
                                [[[#references]]].
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>
        </section>
    </section>

    </section>
    <section>
        <h2 id="versioning">Versioning</h2>
        <section class="informative">
            <h3>Introduction</h3>
            <p>
                Versioning is enabled via <a>version storage</a>; a separate area of the metadata
                model dedicated to storing and managing historical snapshots of <a>nodes</a> and their
                <a>subtrees</a>. Versionable <a>nodes</a> (i.e. those with the type <code>mix:versionable</code>)
                hold references to the historical <a>node</a> snapshots so that they can be discovered
                and acted upon. A <a>node</a> that does not carry the <code>mix:versionable</code> type
                cannot be versioned.
            </p>
            <p>
                A <a>versionable</a> <a>node</a> can be <em>checked-in</em> and <em>checked-out</em>.
                Checking-in creates a <em>new version</em> of the node state along with its <a>versionable
                    subtree</a>. This new version is appended to the version
                history (see [[[#version-history]]]) held within <a>version storage</a> where it can be
                later accessed.
            </p>
            <div class="illustration">
                <p><img src="version-history-simple.png" alt="Simple Versioning Representation" width="700" /></p>
                <p class="caption">A <a>node</a> <code>N</code> with versionable child <code>C</code>
                    along with its version history. Version <code>N<sub>V2</sub></code> is expanded in the
                    illustration showing that the versionable child <code>C<sub>V2</sub></code> is also
                    persisted.
                </p>
            </div>
            <p>
                One of the versions in the version history is marked as the <a>base version</a>. The base
                version is the version against which modifications to a checked-out node are made. That is,
                any changes between the base version and the checked-out node are considered as <a>
                    versionable changes</a>. When node
            </p>
            <p>
                The rules that govern what the version snapshot will include are governed entirely by the <em>on-parent
                    versioning</em> (OPV) attribute of the property definitions and child node definitions defined by
                the primary type and/or mixin types of the versionable node. That is, the <a>types</a> of a <a>node</a>
                prescribe how their data will be managed with respect to versionable state.
            </p>
            <p>
                Each version within a <a>version history</a> can be identified through zero or more labels.

            </p>
        </section>
        <section>
            <h3 id="versionable-nodes">Versionable Nodes</h3>
            <p>
                All <a>nodes</a> (subject to the On-Parent-Version rules outlined in [[[#on-parent-version]]]) may be
                tracked with HMF versioning however only nodes that have the <a>type</a> <code>mix:versionable</code>
                may be checked-in and checked-out (see [[[#checked-in-out]]]). That is, a <a>version node</a> may only
                track a <a>versionable node</a>. Only versionable nodes-trees may be restored.
            </p>
        </section>
        <section>
            <h3 id="checked-in-out">Checked-in &amp; Checked-out State</h3>
            <p>
                A new version of a versionable node is created by checking-in a versionable node. In this state the node
                and its versionable subgraph are read-only. The node can then be checked-out at which point it becomes
                writable again.
            </p>
            <p>
                Checking-in an already checked-in node does nothing. Checking-in a non-versionable node is not
                permitted.
                Checking-in a <a>versionable</a> node stores that node&quot;s <a>versionable state</a> and updates the
                <a>base version</a> of the node.
            </p>
        </section>
        <section>
            <h3>Accessing Versions and Versioned State</h3>
            <p>
                <a>Versionable nodes</a> inherit the <a>reference property</a> <code>hmf:versionHistory</code>
                from <code>mix:versionable</code>. This is a <a>strong reference</a> which can be followed
                to a node of type <code>hmf:versionHistory</code>. The <code>hmf:versionHistory</code> node
                has a set of child nodes of type <code>hmf:version</code> which represent each tracked
                (checked-in) version.
            </p>
            <div class="illustration">
                <p><img src="accessing-versions.png" alt="Accessing Version State" width="600" /></p>
                <p class="caption">
                    Node <code>N<sub>1</sub></code> holds references to the <a>version history</a> and
                    <a>base version</a> through the properties <code>hmf:versionHistory</code> and
                    <code>hmf:baseVersion</code> respectively. The version history contains a child relationships
                    to each version (i.e. with type <code>hmf:version</code>). The <code>hmf:version</code>
                    node itself holds a <a>frozen node</a> which holds the checked-in state of the node
                    <code>N<sub>1</sub></code>.
                </p>
            </div>
            <p>
                The <code>hmf:baseVersion</code> reference on the versionable node holds a reference to the
                version from which changes to the node will be tracked, known as the <a>base version</a>.
                That is, when a node is checked out it holds the state from the <a>base version</a>. A fresh
                check-in will create a new successor in the version history and the base version will be
                moved to the version created by the check-in.
            </p>
        </section>
        <section>
            <h3 id="version-history">Version History</h3>
            <p>
                The <a>version history</a> is a <a>node</a> that holds child relationships to a set of zero or
                more <a>version</a> nodes which themselves represent a single version of a <a>versionable node</a>.
                It has the type <code>hmf:versionHistory</code> and is referenced by a <a>versionable node</a> via the
                reference property <code>hmf:versionHistory</code>.
            </p>
            <div class="illustration">
                <p><img src="version-history-node.png" alt="Version History node" width="800" /></p>
                <p class="caption">
                    Illustrates the <a>version history</a> as referred to via the <code>hmf:versionHistory</code>
                    property found on <code>hmf:versionable</code>.
                </p>
        </section>
        <section>
            <h3 id="frozen-node">Frozen Node</h3>
            <p>
                The <a>frozen node</a> is the static snapshot state of a checked-in <a>versionable</a>. It also
                holds copies of the core metadata in the properties <code>hmf:frozenPrimaryType</code>,
                <code>hmf:frozenMixinTypes</code> and <code>hmf:frozenUuid</code> (as not to collide
                with the properties already held on <code>hmf:frozenNode</code>).
            </p>
            <p>
                The <a>child nodes</a> of a <a>frozen node</a> represent the <a>versionable state</a> of a
                checked-in <a>versionable</a>.
            </p>
        </section>

        <section>
            <h3 id="version-metadata">Version Metadata</h3>
            <p>
                The following fields are available on the version, as defined by the type <code>hmf:version</code>:
            </p>
            <table class="simple">
                <thead>
                    <tr>
                        <th>Property</th>
                        <th>Type</th>
                        <th>Multiple Status</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>hmf:created</code></td>
                        <td><code>type:date</code></td>
                        <td>single</td>
                        <td>
                            Provides the date that the version was created
                        </td>
                    </tr>
                    <tr>
                        <td><code>hmf:predecessors</code></td>
                        <td><code>type:reference</code></td>
                        <td>multiple</td>
                        <td>
                            Provides the direct predecessors of the version history. This is typically
                            a single predecessor.
                        </td>
                    </tr>
                    <tr>
                        <td><code>hmf:successors</code></td>
                        <td><code>type:reference</code></td>
                        <td>multiple</td>
                        <td>
                            Provides the direct successors of the version history. This is typically
                            a single successor.
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>
        <section>
            <h3 id="version-labels">Version Labels</h3>
            <p>
                A zero or more labels can be applied to the version during check-in. The version may be later retrieved
                using one of the labels. Two versions cannot have the same label.
            </p>
        </section>
        <section>
            <h3 id="versionable-state">Versionable State</h3>
            <p>
                The versionable state of a versionable node is typically a subset of its subtree. That is, when a node
                is versioned it may also include some or all of its descendent nodes and their properties.
            </p>
            <p>
                The descendents of a <a>versionable node</a> <code>N</code> that belong to its <a>versionable state</a>
                are determined by the <a>on-parent version</a> status of the child nodes of <code>N</code> (grand-child
                nodes of <code>N</code> do not have their <a>on-parent-version</a> status considered, however they
                do form part of the versionable state). This is best described through an illustration:
            </p>
            <div class="illustration">
                <p><img src="versionable-state.png" alt="Versionable State of N" width="800" /></p>
                <p class="caption">
                    Illustrates the <a>versionable state</a> of node <code>N</code>. <code>N</code> has
                    three child nodes each with different <a>on-parent-version</a> declarations.
                    Child node <code>C<sub>1</sub></code> has an OPV of <code>COPY</code> meaning its
                    child <code>G<sub>1</sub></code> is versionable state.
                    <code>C<sub>2</sub></code>
                    has an OPV of <code>IGNORE</code> meaning it is excluded from the versionable state
                    along with its child.
                    Child node <code>C<sub>3</sub></code> has as an OPV of <code>VERSION</code> meaning
                    that the versionable state becomes a reference to the version history of
                    <code>C<sub>3</sub></code>: <code>V<sub>C3</sub></code>.
                </p>
            </div>
            <p>
                The details of the various OPV values are described in [[[#on-parent-version]]].
            </p>
        </section>
        <section>
            <h3 id="on-parent-version">On-Parent-Version (<abbr title="On-Parent-Version">OPV</abbr>)</h3>
            <p>
                When a <a>versionable</a> <a>node</a> <code>N</code> is checked in, all of the child nodes will be
                evaluated based upon the <em>child node definition</em> (see [[[#child-node-definition]]]) for those
                nodes on <code>N</code>.
                That is, given a child <code>C</code>, the applicable child node definition from the primary type or
                mixin type <code>N<sub>def</sub>C</code> on <code>N</code> for <code>C</code> will be considered as
                follows:
                <ul>
                    <li>if the child node definition <code>N<sub>def</sub>C</code> has an OPV of <code>copy</code>, then
                        the entire subgraph starting at node <code>C</code> will be
                        copied into the version snapshot, regardless of the descendants' OPV settings</li>
                    <li>if the child node definition <code>N<sub>def</sub>C</code> has an OPV of <code>version</code>,
                        then the snapshot will simply contain a placeholder node (of primary type
                        <code>hmf:versionedChild</code>') pointing to the versioned child node</li>
                    <li>if the child node definition <code>N<sub>def</sub>C</code> has an OPV of <code>abort</code>,
                        then an exception will be thrown </li>
                    <li>if the child node definition <code>N<sub>def</sub>C</code> has an OPV of <code>ignore</code> or
                        <code>initialize</code> or <code>compute</code>, then the child node will not be included in the
                        snapshop</li>
                </ul>
                <p class="note">Note that an OPV of COPY can be expensive if the subgraph of that child node contains a
                    lot of descendants.</p>
            </p>
        </section>
        <section>
            <h3 id="versioned-reference">Referencing a Version</h3>
            <p>
                The reference property type holds an identifier to a <a>referenceable node</a>. <a>Version nodes</a>
                are not referenceable. A reference relationship to a <a>versionable node</a> may specify the intended
                version by <a>annotating</a> the reference with standard annotation property
                <code>hmf:versionLabel</code> (see [[[#standard-annotations]]]) with value set as the desired version
                label.
            </p>
        </section>
    </section>
    <section>
        <h2 id="repository">Repository</h2>
        <section class="informative">
            <h3>Introduction</h3>
            <p>
                HMF documents represent HMF <a>trees</a> on disk or on the wire. When HMF trees enter a
                repository they acquire additional behaviour and semantics. This section specifies the
                repository.
            </p>
        </section>

        <section>
            <h3 id="repository-node">Repository Node - <code>hmf:repository</code></h3>
            <p>
                The <a>repository node</a> provides metadata about the repository including features it supports
                and links to other resources within the model.
            </p>
            <table class="simple">
                <thead>
                    <tr>
                        <th>Definition Type</th>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Mandatory Status</th>
                        <th>Multiple Status</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Property</td>
                        <td><code>hmf:namespace</code></td>
                        <td><code>type:string</code></td>
                        <td>optional</td>
                        <td>single</td>
                        <td>
                            A reference property pointing to the <code>hmf:namespaceRegistry</code>.
                        </td>
                    </tr>
                    <tr>
                        <td>Property</td>
                        <td><code>*</code></td>
                        <td><code>*</code></td>
                        <td>-</td>
                        <td>-</td>
                        <td>
                            Allows for any property to be added to the <a>repository node</a>.
                        </td>
                    </tr>
                    <tr>
                        <td>Child</td>
                        <td><code>*</code></td>
                        <td><code>*</code></td>
                        <td>-</td>
                        <td>-</td>
                        <td>
                            Allows for any child to be added to the <a>repository node</a>.
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section>
            <h3>Repository Root</h3>
            <p>
                ???
            </p>
        </section>

        <section>
            <h3>Default Language and Base Direction</h3>
            <p>
                * Default language configuration
                * Default base direction configuration
            </p>
        </section>

        <section>
            <h3 id="move-copy-delete">Move, Copy and Delete Semantics</h3>
            <p>
                * ID behaivour during move
                * Recovering deleted versionables
            </p>
        </section>

        <section>
            <h3 id="namespace-registry">Namespace Registry</h3>
            <p>
                The repository provides access to the <a>namespace registry</a> containing a mapping of
                <a>prefixes</a> to their corresponding <a>namespace IRI</a>.
            </p>
            <section>
                <h4>Default Mappings</h4>
                <p>
                    Repositories contain at least following mappings:
                </p>
                <table class="simple">
                    <thead>
                        <tr>
                            <th>Namespace Prefix</th>
                            <th>Namespace <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>hmf</td>
                            <td>http://hmf.org/ns/hmf/1.0</td>
                            <td>Reserved for <a>items</a> defined within in core <abbr
                                    title="Hierarchical Metadata Framework">HMF</abbr> <a>types</a>
                            </td>
                        </tr>
                    </tbody>
                    <tbody>
                        <tr>
                            <td>mix</td>
                            <td>http://hmf.org/ns/mix/1.0</td>
                            <td>Reserved for the <a>names</a> of built-in <a>mixin</a> <a>node</a> <a>types</a>.
                            </td>
                        </tr>
                    </tbody>
                    <tbody>
                        <tr>
                            <td><em>the empty string</em></td>
                            <td><em>the empty string</em></td>
                            <td>The default namespace is the <em><a>empty namespace</a></em>.
                            </td>
                        </tr>
                    </tbody>
                </table>

            </section>

            <section>
                <h4 id="empty-namespace">Empty Namespace</h4>
                <p>
                    The <a>empty namespace</a> is a permanent and immutable member of the <a>namespace registry</a>
                    which can be used for default data or when <a>namespaces</a> are not required, such as for
                    trivial
                    or single domain metadata storage applications.
                </p>
            </section>
        </section>s
    </section>


    <section>
        <h2 id="internationalization">Internationalization</h2>

        <section class="informative">
            <h3>Introduction</h3>
            <p>
                String literals held within HMF are likely to contain <a data-type="dfn"
                    href="https://www.w3.org/TR/i18n-glossary/#def_natural_language">natural language</a> texts in
                need of <a data-type="dfn"
                    href="https://www.w3.org/TR/i18n-glossary/#def_localizable_text">localization</a> (i.e. language
                translations, language tagging [[BCP47]] and <a data-cite="i18n-glossary#def_base_direction">base
                    direction</a> tagging). HMF follows the recommendations outlines in [[[string-meta]]] and uses <a
                    data-cite="string-meta#language-metadata">field-based metadata</a> to associate
                alternate translations and their associated [[BCP47]] language tags and <a
                    data-cite="i18n-glossary#def_base_direction">base directions</a>. In HMF field-based metadata takes
                the form of <a>annotations</a> (as described in [[[#annotations]]]). Accordingly, HMF provides
                the localizing annotation <code>hmf:localization</code>.
            </p>
            <p class="note">
                HMF does not provide a solution for bidirection text (often referred to as "bidi text") as
                described in <a href="http://www.unicode.org/reports/tr9/">Unicode Standard Annex
                    #9, Unicode Bidirectional Algorithm</a> [[UAX9]]. That is, single string text items with varying
                <a data-cite="i18n-glossary#def_base_direction">base directions</a>. Strings themselves may contain
                unicode <code>U+200F RIGHT-TO-LEFT MARK</code> (RLM) or <code>U+200E LEFT-TO-RIGHT MARK</code> (LRM)
                markers however HMF does not provide model support for such strings.
            </p>
            <p>
                The use of <a>annotations</a> avoids the need for per-language <a>node</a> property names (e.g.
                <code>title_en</code>, <code>title_jp</code>, <code>title_cs</code>...) and allows systems to
                present <a>trees</a> with all localizable strings in a given default language if needed.
            </p>
        </section>
        <section>
            <h3>Localizing Annotation - <code>hmf:localization</code></h3>

            This annotation when applied to a <a>property</a> of type <code>type:string</code> provides a
            <em>list</em> of type <code>type:string</code> where:
            <ul>
                <li>Position <code>[1]</code> - provides the language translation</li>
                <li>Position <code>[2]</code> - provides the language tag in [[BCP47]]</li>
                <li>Position <code>[3]</code> - optionally provides the <em>base direction</em> as
                    either <code>rtl</code> or <code>ltr</code>.
                    Omitting this implies the default base direction. See [[[#default-lang-basedir]]]
                </li>
            </ul>
            For example an annotation of <code>[ "   .", "ar", "rtl" ]</code> provides
            a translation (<code>   .</code>) in Arabic (<code>ar</code>) and indicates
            that the content should be read right-to-left (<code>rtl</code>).
        </section>
        <section>
            <h3 id="default-lang-basedir">Default language and base direction</h3>
            <p>
                In many scenarios there is only a single language used yet it is still desirable to surface the
                language and base direction. In these scenarios a default language is available from the
                <a>repository</a>.
            </p>
            <p class="note">
                HMF does not currently support <a>tree</a>-level default language overrides. In the
                future it may be possible to specify a language and base direction in a node and have
                that cascade to all descendent nodes.
            </p>
        </section>
    </section>



    <section class="informative">
        <h2 id="relationship-to-rdf">Relationship to <abbr title="Resource Definition Framework">RDF</abbr></h2>

        <p>
            The Resource Definition Framework (<abbr title="Resource Definition Framework">RDF</abbr>)
            package of specifications is an attempt to address the general problem of information storage and
            representation on the web. HMF is an attempt to address the specific problem of metadata tree
            storage and representation within organizations. Although their goals are different,
            there are a set of problems germane to metadata representation for which RDF has solutions:
            <ul>
                <li>
                    <b>Graph representation</b> - RDF provides a general purpose <a
                        data-cite="rdf11-concepts#data-model">graph-based data model</a>
                    consisting of facts (formally <a data-cite="rdf11-concepts#resources-and-statements">statements</a>)
                    about <em>things</em> (formally <a
                        data-cite="rdf11-concepts#resources-and-statements">resources</a>)
                    encoded as triplets. RDF introduces the concept of a <a
                        data-cite="rdf11-concepts#dfn-named-graph">named graph</a> which is a powerful
                    building block when working with large metadata datasets. HMF implements restrictions to
                    turn convert the graph-based model into a <em>hybrid hierarchical model</em>
                    ([[[#hybrid-data-model]]]) providing the foundation for tree-capabilities such as
                    <a>path</a>-based <a>location</a> and containment semantics such as copy/move/delete (as
                    described in section [[[#move-copy-delete]]]).
                </li>
                <li><b><a data-link-type="dfn" href="https://tools.ietf.org/html/rfc3987#section-2"><abbr
                                title="Internationalized Resource Identifier">IRIs</abbr></a> for everything</b> -
                    RDF uses IRIs as the means for identification of entities (or in RDF;
                    resources) and types. By design, IRIs have <em>global scope</em> and are safe to use across
                    systems and even organizations without risking <a data-cite="webarch#URI-collision">
                        collisions</a>. HMF follows RDF&apos;s lead and uses IRIs to unambiguously identify
                    <a>nodes</a>, <a>types</a> and in general all <a>entities</a> within the model.
                </li>
                <li><b>Compact IRIs and Namespacing</b> - everything in RDF is identified using an IRI which creates
                    the need for a shorthand alternative to help with readibility. RDF introduces the concepts of a
                    <a data-cite="rdf11-concepts#namespace">namespace and prefix</a> which are used abbreviate an
                    IRI especially during serialization. RDF does not however formally define a namespace within the
                    model, describing them as <em><a data-cite="rdf11-concepts#namespace">merely a syntactic
                            convenience for abbreviating IRIs</a></em>. HMF recognises the need for namespaces as
                    <em>extensible name collections</em> providing named and managed scope.
                </li>
                <li><b>Reification of information and relationships</b> - RDF stores information about
                    resources (or <a>entities</a>) however it is often convenient to capture additional
                    metadata about that information. How did we acquire that information and from whom? For how long
                    is that information valid and how reliable is it? The process of storing such information
                    about knowledge is refered to as <em>reification</em> (see [[[RDFStar]]]). HMF
                    recognises the importance of capturing such information and provides <a>annotations</a>
                    (see also [[[json-ld-star]]]).
                </li>
                <li><b>Encoding and internationalization</b> - . RDF
                    vocabularies support string internationalization (using [[BCP47]] <a
                        data-cite="rdf11-concepts#dfn-language-tag">language tags</a>) as well as mechanisms
                    for specifying a <a data-cite="json-ld11#base-direction">base direction</a> to support
                    non-western languages that are read <em>right-to-left</em>. HMF&apos;s adoption of RDF
                    allows it to take advantage of such internationization capabilities.
                </li>
            </ul>
        </p>
        <p>
            HDF achieves compatibility with RDF by ensuring that:
            <ul>
                <li>the model delineates entities in the <a>domain</a> into <a
                        data-cite="rdf11-concepts#dfn-resource">resources</a>
                </li>
                <li>all <a>resources</a> are identified by an IRI</li>
                <li>names and namespaces expand avoiding the <a data-cite="webarch#def-uri-ownership">assignment of
                        equivalent IRIs to multiple resources</a></li>
                <li>value types are <a data-cite="rdf11-concepts#dfn-rdf-compatible-xsd-types">RDF-compatible</a>
                </li>
            </ul>
        </p>
    </section>

    <section class="appendix informative">
        <h2>Built-in Type Definitions</h2>
        <section>
            <h3 id="type-def-base-type">Base Type - <code>hmf:base</code></h3>
            <p>
                The <a>base type</a> is the <a>node type</a> of all <a>nodes</a> and is the only <a>node type</a>
                not to have a <a>supertype</a>.
            </p>
        </section>
        <section>
            <h3>System Type - <code>hmf:system</code></h3>
            <p></p>
        </section>
        <section>
            <h3>Version History - <code>hmf:versionHistory</code></h3>
            <p></p>
        </section>
        <section>
            <h3>Version - <code>hmf:version</code></h3>
            <p></p>
        </section>
        <section>
            <h3>Frozen Node - <code>hmf:frozenNode</code></h3>
            <p></p>
        </section>
        <section>
            <h3>Referenceable Mixin - <code>hmf:referenceable</code></h3>
            <p></p>
        </section>
        <section>
            <h3>Versionable Mixin - <code>hmf:versionable</code></h3>
            <p></p>
        </section>
        <section>
            <h3>Annotated Mixin - <code>hmf:annotated</code></h3>
            <p></p>
        </section>
    </section>

</body>

</html>