<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Hierarchical Metadata Framework v1.0</title>
    <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove" defer></script>
    <script src="../common/common.js" class="remove" defer></script>
    <script class="remove">
        // All config options at https://respec.org/docs/
        var respecConfig = {
            shortName: "HMF Model",
            specStatus: "base",
            noRecTrack: true,
            editors: [{
                name: "Paul Wilson"
            }, {
                name: "Dave Clark"
            }],
            xref: "web-platform",
            latestVersion: null,
            subtitle: "An abstract model for hierarchical graph metadata",
        };
    </script>
    <style src="../common/style.css" type="text/css"></style>
    <style type="text/css">
        .illustration {
            text-align: center;
        }
    </style>
</head>

<body>
    <p class="copyright">Copyright...</p>
    <section id="abstract">
        <p>
            This document describes the Hierarchical Metadata Framework (HMF), a standard model and
            framework for hierarchical & linked metadata. HMF provides a comprehensive framework
            addressing many aspects of metadata representation including domain modelling, versioning, identity &
            location, navigation, namespacing, reasoning, reification and so on.
        </p>
        <p>
            HMF takes inspiration from a variety of specifications including [[[JSON-LD11]]], [[[RDF-CONCEPTS]]],
            [[[XML]]] and <a
                href="https://developer.adobe.com/experience-manager/reference-materials/spec/jcr/2.0/index.html">Content
                Repository for Java Technology API Specification (JSR-283)</a>. HMF is intended to provide an
            abstract base model upon which concrete vocabularies can be built.
        </p>
    </section>
    <section id="sotd" class="override">
        <h2>Status of this Document</h2>
        <p>This document is in Draft state.</p>

    </section>
    <section class="normative">
        <h2>Terminology & Conventions</h2>
        <section>
            <h3>Terminology</h3>
            <div data-include="../common/terms.html" data-oninclude="restrictReferences"></div>
        </section>

        <section class="normative">
            <h3>Diagram Conventions</h3>
            <p>
                This specification uses diagrams consisting of the following elements
                to clarify concepts within the model:
            </p>
            <table class="simple" style="width:100%">
                <thead>
                    <tr>
                        <th>Element</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><img src="node-convention.png" alt="Node" width="110" /></td>
                        <td>Illustrates a regular <a>node</a>.</td>
                    </tr>
                    <tr>
                        <td><img src="typed-node-convention.png" alt="Node" width="110" /></td>
                        <td>Illustrates a <a>node</a> including its <a>primary type</a> in compact form</td>
                    </tr>
                    <tr>
                        <td><img src="version-convention.png" alt="Node" width="110" /></td>
                        <td></td>
                    </tr>
                    <tr>
                        <td><img src="node-type-convention.png" alt="Node" width="110" /></td>
                        <td></td>
                    </tr>
                </tbody>
            </table>
        </section>
    </section>

    <section class="information">
        <h1 id="introduction">Introduction</h1>
        <p>
            <abbr title="Hierarchical Metadata Framework">HMF</abbr> is a
            framework for hierarchical metadata. It provides a foundation for organising, querying, inferencing,
            change-tracking and administering the metadata trees and graphs that lie at the heart of modern
            web and media organisations. <abbr title="Hierarchical Metadata Framework">HMF</abbr> was conceived as
            a foundation for <em>media-content</em> curation and syndication, but was designed to be agnostic
            to any domain where metadata is <em>primarily hierarchical</em>.
        </p>
        <p>
            <abbr title="Hierarchical Metadata Framework">HMF</abbr> allows for information to be captured and
            formalized
            within the model through <a>types</a>. <a>Types</a> categorise, characterise and constrain metadata and
            so serve as building blocks for robust applications. <a>Types</a> can be applied to metadata at <em>any
                point during its lifecycle</em> allowing for raw and unstructured data to be edited and reasoned into
            formalised, semantically rich trees.
        </p>

        <hr />

        <p>
            By focusing on domains where metadata is organised primarily into hierarchies,
            <abbr title="Hierarchical Metadata Framework">HMF</abbr> supports a rich set of semantics that
            would be otherwise unavailable:
            <dl>
                <dt>Move, Copy & Delete</dt>
                <dd>Move, copy & delete operations applied on a <a>node</a> apply to the their entire <a>subtree</a>.
                    This is
                    conceptually identical to copying files and folders on a filesystem and allows metadata to be
                    organised and managed whilst preserving structure.</dd>
                <dt>Child Node Constraints</dt>
                <dd>HMF allows <a>child node constraints</a> to dictate which child-types are permitted on a
                    <a>node</a>.
                    Using child node constraints, we can build metadata trees with <em>strong guarantees</em> about the
                    validity of both data and structure.
                </dd>
                <dt>Cascading Access Control</dt>
                <dd>Permissions and access control directives can be applied to <a>nodes</a> and to all
                    descendents
                    in a <em>cascading</em> fashion. Much like a filesystem, user or group principals therefore can own
                    and administer entire <a>subtrees</a> without the overhead of permission-management of every node.
                </dd>
                <dt>Tree Versioning</dt>
                <dd>When a specific version of a <a>node</a> is tracked, it is often desirable to also track its
                    subtree.
                    HMF allows subtrees of a <a>versionable</a> <a>node</a> to be automatically tracked when the owning
                    <a>versionable</a> <a>node</a> is checked-in.
                </dd>
                <dt>Location & Navigation</dt>
                <dd><a>Trees</a> give <a>nodes</a> and <a>properties</a> a <em>location</em> as defined by its
                    <a>path</a> relative to the metadata <a>root</a>. This means information not only has
                    <a>identity</a>
                    but also <a>location</a> allowing for metadata to be discovered or accessed relative to other
                    metadata
                    via the process of <a>navigation</a>. <a>Navigation</a> allows knowledge to be <em>explored</em>
                    without prior information about what is available or even the structure of the metadata tree.</dd>

            </dl>
        </p>

        <hr />

        <p>
            <abbr title="Hierarchical Metadata Framework">HMF</abbr> represents metadata as a <em>linked data
                graph</em> (see [[[Linked-Data]]]). All <a>entities</a> including <a>nodes</a> and <a>properties</a>
            represented by an HMF model are unambigiously
            identified using an <a data-link-type="dfn" href="https://tools.ietf.org/html/rfc3987#section-2"><abbr
                    title="Internationalized Resource Identifier">IRI</abbr></a>. Using a universally unique
            resource identifier for all atoms of data allows systems to precisely resolve ownership and
            meaning of knowledge held within HMF. Using IRIs as the foundation identifier along with <a>namespacing</a>
            also allows HMF to represent knowledge describing a common subject but belonging to unrelated systems or
            sources without collision or ambiguity. It also allows modules and components to be registered against
            subsets of metadata (as identified by a <a>namespace IRI</a>) stored within HMF whilst ignoring
            irrelevant subsets.
        </p>

        <hr />

        <p>
            This document provides the <em>abstract</em> model for <abbr
                title="Hierarchical Metadata Framework">HMF</abbr>, defining structure and semantics
            independent of any particular representation, encoding or concrete syntax. This separation allows for
            concrete vocabularies to be defined external to this document each providing their own model representation
            for metadata interchange and delivery.
        </p>

        <section class="informative">
            <h2 id="key-concepts">Key Concepts and Rationale</h2>
            This section highlights some of the key ideas found in <abbr title="Hierarchical Metadata">HMF</abbr>.
            <section>
                <h3 id="nodes-trees">Hybrid Hierarchical-Graph Model</h3>
                <p>
                    <abbr title="Hierarchical Metadata">HMF</abbr> provides a modelling framework
                    for metadata that fits naturally into a <a>tree</a> of <a>nodes</a>. The <a>tree</a>
                    structure is convenient for organising information in such a way that related
                    metadata can be explored, located, access controled, constrained, versioned,
                    moved or deleted easily.
                </p>

                <p>
                    <a>Trees</a> model sets of <em>one-to-many</em> relationships only. Although fine for some
                    applications it's unlikely to be adequate for non-trivial metadata domains. <abbr
                        title="Hierarchical Metadata">HMF</abbr> therefore allows <a>nodes</a> to reference
                    arbitrary <a>nodes</a> irrespective of whether they share an ancestry. This allows for
                    <em>many-to-many</em> relationships to be modelled within <abbr
                        title="Hierarchical Metadata">HMF</abbr>. The following illustration shows <a>nodes</a>
                    connected by both <a>tree</a> relationships and arbitrary relationships.
                </p>

                <div class="illustration">
                    <p><img src="hybrid-graph-hierarchical.png" alt="Hybrid Graph Hierarchical Model" width="400" /></p>
                    <p class="caption">Hybrid Graph Hierarchical Model</p>
                </div>
                <p class="ednote" title="Illustration needs updating">
                    This illustration needs updating inline with the diagram conventions.
                </p>
                <p>
                    The result is a <i>hybrid-graph</i> model which benefits from first-class <a>tree</a>
                    modelling without limiting which <a>nodes</a> may be related.
                </p>

            </section>

            <section>
                <h3 id="namespaces">Namespaces</h3>

                <p>
                    <a>Namespaces</a> separate data belonging to different domains or arriving from different
                    sources into well-defined, recognisable and distinguishable groupings referenced using an
                    <abbr title="Internationalized Resource Identifier">IRI</abbr>. In <abbr
                        title="Hierarchical Metadata">HMF</abbr> both <a>nodes</a> and <a>properties</a>
                    are namespaced, meaning that structural and value elements of the model exist not only
                    within the <a>tree</a> but also within a <a>namespace</a>.
                </p>
                <div class="illustration">
                    <p><img src="namespaces.png" alt="Nodes and Properties Occupying Namespaces" width="600" /></p>
                    <p class="caption">Nodes and Properties Occupying Namespaces (<code>ns1</code> & <code>ns2</code>)
                    </p>
                </div>
                <p>
                    <a>Namespaces</a> allow for <a>items</a> to be unambigiously identified within the model,
                    leading to the following benefits:
                    <ul>
                        <li>Nodes and properties arriving from independent sources may coexist within a
                            <a>tree</a> without threat of naming collisions.
                        </li>
                        <li>
                            Metadata consumers may use the namespace to understand additional type information
                            about <a>items</a> in the <a>tree</a> and may even use the namespace to resolve
                            further type information about that data.
                        </li>
                        <li>
                            Consumers only interested in a subset of namespaces may mask away values or even
                            entire sub-trees that are not relevant to their needs.
                        </li>
                        <li>
                            User interface components may represent data belonging to an individual namespace in unique
                            and distinct ways
                        </li>
                        <li>
                            Plugin components within software systems built atop HMF may be registered and
                            activated when data belonging to a specific namespace is present.
                        </li>
                    </ul>
                </p>

            </section>

            <section>
                <h2>Types & Domain Modelling</h2>
                <p>
                    <a>Types</a> in <abbr title="Hierarchical Metadata Framework">HMF</abbr> provide the means
                    to <em>represent knowledge</em> within the sytem through <a>formalisms</a> about a given domain
                    within the metadata model. HMF is unique in that types are themselves <em>first-class
                        metadata</em> within the model. Types may be dynamically applied and modified without
                    compromising the integrity of the metadata <a>trees</a> they formalise.
                </p>
                <p>
                    The dynamic nature of types makes HMF ideally suited to applications where metadata is
                    modified and matured within the system until it is ready for export or delivery. Metadata
                    may arrive in a raw and unstructured form and have types progressively applied
                    until meeting the preconditions for a downstream system. HMF allows
                    a <a>node</a> or <a>tree</a> to be evaluated in terms of types, and then for that type
                    to be applied.
                </p>
                <p>
                    Types categorise and constrain both values (i.e. held within <a>properties</a>) as well as
                    the hierarchical structure of a <a>tree</a>. By enforcing that a <a>node</a> and its descendents
                    have specific <a>node</a> types, HMF can make <em>strong guarantees</em> about what clients
                    can expect as they traverse and <a>tree</a> hierarchy and its data.
                </p>
            </section>
            <section>
                <h2 id="versioning-intro">Versioning</h2>

                <p>
                    HMF&quot;s versioning capability allows the state of a <a>node</a> and its subtree to be
                    recorded and later accessed, restored or referenced. Versioning is key for editorial scenarios
                    where metadata changes may need to be reverted, or a record of modifications is needed for
                    auditing purposes. Also the ability have a <a>node</a> hold a <a>reference</a> to a version
                    of another <a>node</a> means it can guarantee the state of the referenced node and its immutability.
                </p>
                <div class="illustration">
                    <p><img src="versioning-introduction.png" alt="Node Versioning & Version Storage" width="600" /></p>
                    <p class="caption">A <a>node</a> with versions (<code>v1,v2,v3</code>) available in <a>version
                            storage</a>
                    </p>
                </div>
                <p>
                    Versions in HMF provide a snapshot of the state of a <a>node</a> and its <a>versionable subtree</a>
                    in much the same way that a version control system holds the historical state of the filesystem.
                    In HMF, version histories are linear changesets and the standard model does not provide the means
                    to branch and merge version histories in the same way that modern version control systems can. That
                    is, versioning in HMF is a means to track historical state; it is not the basis for a branch-based
                    editorial workflow.
                </p>

            </section>
            <section>
                <h2 id="annotations-intro">Annotations</h2>

                <p>
                    <a>Annotations</a> address the problem of how to capture additional information about
                    the <a>properties</a> and <a>relationships</a> of a <a>node</a>. For example, a
                    <a>node</a> may contain a <a>property</a> named <code>title</code> with a value,
                    however we may want to record additional information such as certainty scores, weights,
                    temporal restrictions, permissions and provenance information. Annotations are
                    therefore <a>properties</a> <em>about <a>properties</a> or <a>relationships</a></em>.
                </p>
                <p>
                    The following illustration shows annotation properties capturing additional information
                    about the <code>title</code> <a>property</a>; the timestamp of when the data was
                    <code>provided</code>.
                    We might also choose to store which data source provided this property or when the
                    information is due to expire or need reviewing:
                </p>

                <div class="illustration">
                    <p><img src="annotation-example.png" alt="Property Annotation" width="600" /></p>
                    <p class="caption">Annotation of a Property</p>
                </div>

                <p>
                    An annotation can also be applied to a <a>relationship</a> to capture additional
                    information about the relation. An annotation may contain a reference to another
                    <a>node</a> offering a way to indirectly link <a>nodes</a> to both <a>properties</a>
                    and child <a>relationships</a>. Annotations are versioned along with the <a>node</a>
                    so that the annotated state is captured alongside checked-in node state.
                </p>

                <p>
                    Annotations are a simple but powerful feature of HMF. They can be used to capture
                    elaborate multi-dimensional structures around the core metadata domain.
                </p>

            </section>
        </section>
    </section>
    <section>
        <h2 id="representation">Tree Primitives</h2>
        <section class="informative">
            <h3>Introduction</h3>
            <p>
                Core to the HMF standard model is the concept of a <a>tree</a> consisting of a graph
                of <a>items</a>. The term <a>item</a> refers to both <a>nodes</a> and <a>properties</a>
                which together provide the primitives for representing the <em>values</em> and <em>structure</em>
                of metadata. All <a>items</a> are said to have a <a>location</a> which can be represented
                using a <a>path</a> (see [[[#paths]]]).
            </p>
            <p>
                This section describes how HMF uses <a>items</a> to store and organise metadata.
            </p>
        </section>
        <section>
            <h3 id="nodes">Nodes</h3>
            <section class="informative">
                <h4>Introduction</h4>
                <p>
                    <a>Nodes</a> represent <a>entities</a> and provide the <i>structure</i> to data within the <abbr
                        title="Hierarchical Metadata Framework">HMF</abbr> model. They provide
                    identity and type, as well as relationships to other <a>nodes</a>. It is through <a>nodes</a> that
                    content hierarchies are formed, with one <a>node</a> able to act as a <i>parent</i> or
                    <i>container</i> for another <a>node</a>.
                </p>
                <div class="illustration">
                    <p><img src="hmf-nodes.png" alt="Nodes" width="400" /></p>
                    <p class="caption">Nodes with parent and child relationships</p>
                </div>
                <p>
                    Nodes have <a>names</a> (see [[[#names]]]) which identify them among their siblings and are used
                    as <a>segments</a> in <a>paths</a> (see [[[#path-segments]]]). Nodes also have a universally
                    unique <a>identity</a> encoded as an IRI (see [[[#node-identity]]]) allowing a node to be resolved
                    independently of its location.
                </p>
                <p>
                    <a>Nodes</a> have a single <i>parent</i> relationship to their <i>parent</i> <a>node</a> (except
                    for the <a>root node</a>, see [[[#root-node]]]), and zero-or-more <i>child</i> <a>nodes</a>.
                    These parent-child relationships form an acyclic graph (formally referred to as a <a>tree</a>)
                    holding the primary structure of the metadata. All <a>nodes</a> are connected to all other nodes
                    via parent-child relationships, if only via the <a>root node</a>.
                </p>
                <p>
                    <a>Nodes</a> may be <em>copied</em>, <em>moved</em> and <em>deleted</em>. These operations affect
                    each of their ancester <a>nodes</a> to.
                </p>
                <p>
                    A <i>child</i> is affected by its parent and ancestors in various ways. For example, <i>copy</i> and
                    <i>move</i> operations on a <a>node</a> will recursively copy the <a>node</a>'s descendents (see
                    [[[#move-copy]]]). Permissions applied within a <a>repository</a> to a parent will <i>cascade</i> to
                    descendents. The versioning strategy applied to a <a>node</a> will govern the <i>read-only</i>
                    status of a child when the parent is checked-in (see [[[#versioning-semantics]]]).
                </p>
                <p>
                    <a>Nodes</a> also act as a container for <a>properties</a> as described in [[[#properties]]].
                    All <a>nodes</a> carry a small set of mandatory properties (see [[[#mandatory-properties]]]).
                </p>
                <p>
                    <a>Nodes</a> have a <a>type</a> (see [[[#node-types]]]) which defines the core characteristics
                    of the node. Nodes have a single <a>primary type</a> and zero or more <a>mixin types</a> which
                    together define what properties and child nodes are required or permitted on the name, and their
                    respective types. Nodes have an <em>is-a</em> relationship with each of its types.
                </p>
            </section>

            <section>
                <h3 id="node-names">Node Names</h3>
                <p>
                    Each <a>node</a> has a <a>name</a> used to locate the <a>node</a> among its siblings. The
                    <a>node</a>
                    <a>name</a> is used within <a>paths</a> to allow <a>nodes</a> to be located without knowing their
                    <a>identity</a>. See [[[#names]]] for a full description of <a>names</a>.
                </p>
            </section>

            <section>
                <h3 id="node-identity">Node Identity</h3>
                <p>
                    Relying on a <a>path</a> to locate a <a>node</a> could be problematic when we consider that
                    <a>nodes</a> can be moved. In cases where a <a>node</a> must be retrievable irrespective of
                    its location in the hierarchy, we may rely instead on <a>node identity</a>.
                </p>
                <p>
                    A <a>node</a> that can be retrieved using its <a>identity</a> is said to be <a>referenceable</a>.
                    Storage systems would typically use an <a>index</a> to quickly locate a <a>referenceable</a>
                    <a>node</a> within a <a>repository</a>. Maintaining such an index incurs a cost in terms of
                    resources
                    and performance as it would need to be stored and maintained within the storage system. It
                    becomes therefore a <i>design choice</i> as to whether a given node should be <a>referenceable</a>.
                </p>
                <p>
                    <a>Nodes</a> can be related to one another via <a>references</a> as described in
                    [[[#references]]].
                    <a>Node</a> <a>identity</a> is used to support <a>references</a> as only <a>nodes</a>
                    that are <a>referenceable</a> can be referred to from a <a>node</a>.
                </p>
                <p>
                    If a given <a>node</a> has the <i>mixin type</i> (see [[[#primary-mixin-types]]]) of
                    <code>mixin:referenceable</code> then the <a>node</a> is <a>referenceable</a>.
                    <a>Referenceable</a> <a>nodes</a> acquire the <a>property</a>
                    <code>lhd:uuid</code> from the <code>mixin:referenceable</code> type which holds a universally
                    unique
                    <a>repository</a>-managed identifier.
                    This identifier may be used outside of a <a>repository</a> to reference the <a>node</a> and
                    acts as the <a>value</a> of <a>reference</a> <a>properties</a> (see [[[#references]]]).
                </p>
            </section>
            <section>
                <h3 id="root-node">Root Node</h3>
                <p>

                </p>
            </section>
            <section>
                <h3 id="mandatory-properties">Mandatory Properties</h3>
                <p>
                    All <a>nodes</a> contain the following mandatory <a>properties</a>:
                    <table class="simple">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>hmf:primaryType</code></td>
                                <td><code>type:string</code></td>
                                <td>The <a>compact IRI</a> of a <a>node</a>'s primary type (see
                                    [[[#primary-mixin-types]]])
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </p>
            </section>
            <section>
                <h3 id="primary-mixin-types">Primary & Mixin Types</h3>
                <p>
                    All <a>nodes</a> have one or more <a>types</a> which enforce restrictions on the required and
                    permitted child nodes and properties (see [[[#types]]]). All
                </p>
            </section>
            <section>
                <h3>Node Size Limitations</h3>
            </section>
        </section>


        <section>
            <h2 id="properties">Properties</h2>
            <p>
                <a>Properties</a> belong to <a>nodes</a> and hold the <i>data</i> or <a>values</a> associated with
                that <a>node</a>. A <a>property</a> consists of a <a>name</a> as defined in [[[#names]]] and zero
                or more <a>values</a> of a specific <a>type</a>.
            </p>
            <p>
                The <a>type</a> of a <a>property</a> determines the range of <a>values</a> it can store and is defined
                by
                a <a>datatype IRI</a>.
            </p>
            <section>
                <h3 id="mult-value-properties">Multi-value Properties</h3>
                <p>
                    Properties can either be <em>single-valued</em> or <em>multi-valued</em>.
                </p>
                <p>
                    A single-value property, if it exists, must have a value. There is no such thing as a <em>null</em>
                    value. A multi-value property can have zero or more values. Again there is no such thing as a null
                    value, however a multi-value property can be empty, just as an array can be empty.
                </p>
                <p>
                    Whether a particular property is a multi-valued property is governed by the property definition
                    applicable to it, which is determined by the node type of the property's parent node (see
                    [[[#node-types]]]).
                </p>
                <section>
                    <h4 id="property-array-semantics">Array Semantics</h4>
                    <p>
                        The values stored within a multi-valued property are all of the same type. A multi-valued
                        property
                        by default has <em>array</em> semantics. That is, they are <em>ordered</em> and may contain
                        <em>duplicate</em> values.
                    </p>
                </section>
                <section>
                    <h4 id="property-set-semantics">Set Semantics</h4>
                    <p>
                        A multi-value property can be declared to have <em>set</em> semantics. In this case, the
                        property
                        will only every contain unique values and there will be no defined ordering.
                    </p>
                </section>
            </section>
        </section>


        <section>
            <h2 id="names">Names &amp; Namespaces</h2>
            <p>
                <a>Names</a> in <abbr title="Hierarchical Metadata Framework">HMF</abbr> are conceptually the same as
                <a>names</a> in [[XML]]. They consist of a <a>namespace IRI</a> (or the empty string in the case of
                [[[#empty-namespace]]]) and a <a>local name</a>, and are written in their expanded form as
                <code>{NAMESPACE}LOCAL_NAME</code>, for example:
            </p>
            <p>
                <code>{http://hmf.org/ns/hmf/1.0}primaryType</code>
            </p>
            <p>
                <code>NAMESPACE</code> is either the empty string <code>""</code> or a <a>namespace IRI</a> that
                identifies the <a>namespace</a> and must be <em>registered</em> within the <abbr
                    title="Hierarchical Metadata Framework">HMF</abbr> storage layer before it is used.
            </p>
            <p>
                <a>Namespaces</a> are <em>registered</em> along with a <a>prefix</a> allowing <a>names</a> to be
                written in their <em>compact</em> form; <code>PREFIX:LOCAL_NAME</code>, for example:
            </p>
            <p>
                <code>hmf:primaryType</code>
            </p>
            <p>
                The compact form of a <a>name</a> is commonly used, however a namespace mapping of <a>prefixes</a>
                to <a>namespace IRIs</a> must be supplied.
            </p>
            <p>
                <div class="note">
                    <p>
                        [[XML]] and [[RDF-CONCEPTS]] both use resource identifiers as names but in subtly different
                        ways.
                        In [[XML]] a name is an <em>ordered pair</em> consisting of a <a>namespace IRI</a> and a
                        <a>local
                            name</a>
                        which is commonly written in the form <a>namespace</a>:<a>local name</a>. A <a>namespace IRI</a>
                        must be formally <em>declared</em> before its corresponding <a>prefix</a> may be used and there
                        is no explicit formal specification for how a pair should be treated or expressed.
                    </p>
                    <p>In contrast, [[RDF-CONCEPTS]] states that subjects are represented with an IRI which can be
                        conveniently
                        written as a <a>compact IRI</a> in the form <a>prefix</a>:<em>suffix</em>. In [[RDF-CONCEPTS]],
                        this <a>compact IRI</a> can be expanded via simple concatentation to reveal the subject IRI,
                        with
                        no deterministic way to return to the <a>compact IRI</a> form.
                    </p>
                    <p> The absence of a formal definition
                        of namespaces in [[RDF-CONCEPTS]] means that a document could contain overlapping prefixes where
                        different <a>compact IRIs</a> expand to the same IRI during concatenation, thus mangling their
                        namespaces.
                    </p>
                    <p>
                        <abbr title="Hierarchical Metadata Framework">HMF</abbr> chooses to follow [[XML]] defining a
                        <a>name</a> as an ordered pair and provides a <a>namespace registry</a> to map <a>prefixes</a>
                        to their <a>namespace IRIs</a>. The result is that all <a>names</a> belong to a specific
                        <a>namespace</a>.
                    </p>
                </div>
            </p>
            <section>
                <h3>Local Name</h3>
                <p>

                </p>
            </section>
            <section>
                <h3>Naming Restrictions</h3>

                <p>
                    The characters declared invalid within a local name (“/”, “:”, “[“, “]”, “|”, “*”) represent only
                    those
                    characters which are used as metacharacters in JCR names, paths and name-matching patterns (see
                    §5.2.2
                    Iterating Over Child Items). These restrictions are not necessarily sufficient to enforce best
                    practices
                    in
                    the creation of JCR names. In particular, the minimal grammar defined here permits JCR names with
                    leading
                    and trailing whitespace as well as characters which may appear superficially identical while
                    representing
                    different code points, creating a potential security issue.
                </p>
            </section>

            <section>
                <h3 id="empty-namespace">The Empty Namespace</h3>
                <p>
                    For trivial or single-source metadata applications, enforcing a <a>namespace</a> could be overly
                    burdensome. <abbr title="Hierarchical Metadata Framework">HMF</abbr> provides a permanent <a>default
                        namespace</a> with prefix <code>""</code> (i.e. the empty string), also referred to as the
                    <a>empty namespace</a>. This allows <a>names</a> to omit the <a>prefix</a> and be located using
                    their
                    <a>local name</a> only.
                </p>
            </section>
        </section>

        <section>
            <h2 id="annotations">Annotations</h2>
            <p>
                Annotations capture additional metadata about node&quot;s <a>properties</a> and relationships. For each
                <a>item</a> of a <a>node</a> we can access its <a>annotation</a> which is itself a collection of
                properties. Annotation properties can be of any type available to regular properties, however these
                properties are themselves not annotatable.
            </p>
            <p>
                <a>Nodes</a> that have the <a>mixin</a> type <code>mix:annotated</code> are said to be
                <em>annotated</em>. It's only possible to access annotations on nodes with this <a>mixin</a>
                type. The means for accessing annotations are implementation specific.
            </p>
            <p>
                <div class="note">
                    <p>The two popular graph-based data models have been RDF [[RDF11-CONCEPTS]] and
                        <a href="https://en.wikipedia.org/wiki/Graph_database#Labeled-property_graph">Labeled-property
                            Graphs</a>,
                        which are roughly similar, with the RDF model being more formal in identifying <a>nodes</a>,
                        datatypes and relationships, while Property Graphs
                        use a less formal relationship model somewhat similar to JSON. In both models,
                        nodes are related via edges (AKA arcs), but in Property Graphs,
                        those edges may themselves be annotated with properties.
                        This is useful in providing additional metadata and semantics to relationships
                        of the <a>nodes</a>.
                    </p>
                    <p>
                        <abbr title="Hierarchical Metadata Framework">HMF</abbr> takes a hybrid approach
                        by providing an RDF-style model that uses IRIs to formally identify <a>entities</a> whilst
                        allowing node properties and relationships to be annotated with additional metadata
                        as with labeled property graphs (LPGs).
                    </p>
                </div>
            </p>
            <p>
                Annotations are considered as part of a <a>node</a>&quot;s <a>versionable tree</a>.
                It is not currently possible to enforce mandatory annotations or any other property
                type declarations on annotation properties.
            </p>
            <section>
                <h3>Standard Annotations</h3>
                <p>
                    The following annotations enable functionality in HMF.
                </p>
                <p class="ednote" title="Should maybe expanded out into a separate section">
                    It may be appropriate to have specific sections detailing the various
                    standard annotations.
                </p>
                <table class="simple">
                    <thead>
                        <tr>
                            <th>Type <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>hmf:versionLabel</code></td>
                            <td>
                                Used to annotate <a>reference types</a> with a specific version label. When
                                the annotation reference property is resolved to a <a>node</a>, the version of
                                that <a>node</a> with the <a>version label</a> provided in this annotation
                                should be retrieved. It is assumed that the target node of the reference has the
                                <a>mixin</a> type <code>mix:versionable</code>. See [[[#versioned-reference]]].
                            </td>
                        </tr>
                        <tr>
                            <td><code>hmf:ordering</code></td>
                            <td>
                                Indicates whether the annotated multi-value property is <em>ordered</em> or
                                <em>un-ordered</em>. If the annotation has the value <code>list</code> then
                                the multi-value property is ordered. If the annotation has the value <code>set</code>
                                then the multi-value property is unordered. This annotation provides additional
                                semantics allowing clients to interpret a multi-value property appropriately.
                                If the annotated property is single-valued then this annotation is redundant.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>
        </section>
    </section>

    <section>
        <h2>Relationships & Navigation</h2>
        <section>
            <h2>Relationships</h2>
            <section>
                <h3 id="parent-child-relationships">Parent-Child Relationships</h3>
                <p>
                    <abbr title="Hierarchical Metadata Framework">HMF</abbr> has <i>first-class</i> support for
                    <i>parent-child</i> relationships between <a>nodes</a>. Parent-child relationships have additional
                    semantics beyond what are provided for regular [[[#references]]]. For example, a child is considered
                    to belong to its parent, meaning that re-locating the parent also relocates the child. Versioning a
                    parent in many cases will also version the child. A parent's <a>type</a> may also enforce that it
                    has a child with a given <a>name</a> and <a>type</a>.
                </p>
                <p>
                    Parent-child relationships can be said to define the <a>tree</a> structure metadata.
                </p>
                <p>
                    <a>Trees</a> allow <a>paths</a> to be used to locate a <a>node</a>. <a>Paths</a> can only
                    be used to traverse <em>parent-child</em> relationships and do not apply to <a>references</a>.
                    <a>Nodes</a> can be referenced either using their identity or using their location as defined
                    by their <a>path</a> from the <a>root</a> to the <a>node</a>.
                </p>
                <p>
                    [[[#primary-child]]] allows clients to navigate through parent-child relationships without
                    knowing the names of the intermediate
                </p>
                <p>
                    First class support in type system (types can declare child types)
                </p>
                <p>
                    <abbr title="Hierarchical Metadata Framework">HMF</abbr> does not support <a>same name siblings</a>.
                    That is, all children must have a unique name.
                </p>
            </section>
            <section>
                <h3 id="references">Reference Properties</h3>
                <p>
                    A <a>node</a>
                </p>
                <section>
                    <h4 id="strong-weak-references">Strong and Weak References</h4>
                    <p>

                    </p>
                </section>
                <section>
                    <h4 id="versioned-references">Versioned References</h4>
                    <p>
                        Versioned references allow a property to hold a reference to a specific version of a node,
                        guaranteeing that the reference resolves to an immutable and known node state. This is a
                        key building block for systems where a <em>stable</em> or <em>promoted</em> version of a
                        a <a>node</a> must be referenced whilst simultaneously edited.
                    </p>
                    <p>
                        <div class="illustration">
                            <p><img src="versioned-reference.png"
                                    alt="Annotation Specifying the Label of a Versioned Reference" width="700" /></p>
                            <p class="caption">Annotation Specifying the Label of a Versioned Reference</p>
                        </div>
                    </p>
                    <p>
                        The annotation <code>hmf:versionLabel</code> should contain the <a>version label</a> of the
                        desired version. Clearly the target node should have the <a>mixin</a> type
                        <code>mix:versionable</code>.
                    </p>
                </section>

            </section>
            <section>
                <h3 id="primary-child">Primary Child</h3>
                <p>
                    A [[[#node-type]]] can declare <em>one</em> of its children as primary, meaning that for all
                    <a>nodes</a> of
                    that type, that child is accessible in a way that does not require the name of the item. Primary
                    children
                    allow clients to traverse a <a>tree</a> without upfront knowledge of the <a>node</a> structure.
                </p>
                <p>
                    A client could for example know to traverse a <a>tree</a>&quot;s primary children until a
                    <a>node</a> of
                    a given <a>type</a> or <a>name</a> is encountered. This would allow editors to modify a
                    <a>tree</a>&quot;s
                    structure, perhaps be adding or removing intermediate nodes, without breaking the client.
                </p>
            </section>
        </section>
        <h2 id="paths">Paths</h2>
        <p>
            A HMF path allows an <a>item</a> to be resolved in terms of its <em>location</em> within the <a>tree</a>
            rather than its <em>identity</em>. In some scenarios, <em>location</em> is preferred over <a>identity</a>
            because resolution needs to happen with respect to a <a>node</a>&quot;s position relative to another
            <a>node</a>
            (including the <a>root</a>).
        </p>
        <section>
            <h3 id="path-segments">Path Segments</h3>
            <p>
                Paths are an ordered list of path <a>segments</a> <em>S = (P0,P1,...,PN)</em> of which there are the
                following types:
                <ul>
                    <li>A compact name segment with the <a>name</a> in its <a>prefix</a> form, such as
                        <code>acme:episode</code></li>
                    <li>An expanded name segment with the <a>name</a> in its expanded form, such as
                        <code>{http://acme.org/ns/}episode</code></li>
                    <li>the identifier segment where a <a>node</a> is identified by its identity</li>
                    <li>the versioned identifier segment where a version of a <em>versionable</em> node is identified
                        using the identity of its base version and a version <em>label</em></li>
                    <li>the versioned name segment where a version of a <em>versionable</em> node is identified
                        using its <a>name</a> and a version <em>label</em></li>
                    <li>the root segment which identifies the <a>root</a> node</li>
                    <li>the self segment which identifies the contextual node</li>
                    <li>the parent segment which identifies the parent <a>node</a> of the contextual node</li>
                </ul>
            </p>
            <p>
                The <em>root</em>, <em>self</em> and <em>parent</em> segments are constants with intuitive
                lexical forms as described in [[[#path-lexical-form]]].
            </p>
        </section>
        <section>
            <h4>Compact Name Segment</h4>
        </section>
        <section>
            <h4>Expanded Name Segment</h4>
        </section>
        <section>
            <h4>Versioned Name Segments</h4>

        </section>
        <section>
            <h4>Identifier Segments</h4>

        </section>
        <section>
            <h4>Versioned Identifier Segments</h4>

        </section>
        <section>
            <h4>Root Segment</h4>
        </section>
        <section>
            <h4>Self Segment</h4>
        </section>
        <section>
            <h4>Parent Segment</h4>
        </section>
        <section>
            <h3 id="path-lexical-form">Lexical Form</h3>
            <p>

            </p>
        </section>
        <section>
            <h3 id="traversal">Path Traversal</h3>
            <p>
                Intermediate nodes may not exist due to permission restrictions
            </p>
        </section>
    </section>

    <section>
        <h2 id="types">Types</h2>
        <section class="informative">
            <h3>Introduction</h3>
            <p>
                Types are a fundamental and foundational component of <abbr
                    title="Hierarchical Metadata Framework">HMF</abbr>
                since they are the means for <em>domain knowledge</em> to be formalised within the model.
                Types capture the characterstics and structure of a given metadata model and offer strong
                guarantees about the data it holds.
            </p>
            <p>
                Types provide a <em>classification</em> to <a>nodes</a> and <a>properties</a>. This classification
                indicates the range of possible values that can be held and in the case of <a>nodes</a>, the
                types of child <a>nodes</a> it may posses. ...
            </p>
            <p>
                HMF provides <em>two forms</em> of <a>types</a>:
                <ul>
                    <li><em>Property Types</em> - indicates the data type of a property, whether it is
                        mandatory, mulit-valued, a default value and some additional value constraints (such as
                        a regular expression for <code>type:string</code> properties)</li>
                    <li><em>Node Types</em> - indicates the set of allowed <a>properties</a> and
                        child <a>nodes</a>, a <a>primary child</a> and the set of other <a>types</a> from which
                        it inherits.</li>
                </ul>
            </p>
            <p>
                Node types may be dynamically modified within an application assuming the changes are compatible
                with all <a>nodes</a> of that type. For example, a new <em>non-mandatory</em> field or a
                mandatory field with a default value may be added to a node type. If a node type applies further
                restrictions, then all <a>nodes</a> with that type must first conform to those restrictions before
                the modification will be allowed.
            </p>
            <p>
                Node types may be dynamically applied <a>nodes</a> within a <a>tree</a>. This means that once a
                node conforms to a given type, that type may be applied as its primary type or <em>mixed-in</em>
                to that node. This allows editorial pipelines to be constructed where additional types are added
                to metadata as it matures through the system.
            </p>
        </section>
        <section>
            <h3 id="property-type-definition">Property Definition</h3>
            <p>
                Properties have a <a>type</a> which controls the values it may hold, such as <code>type:string</code>
                or <code>type:integer</code>. When a property is defined within a <a>node type definition</a> it is
                also subject to a <a>property type definition</a> declaring the following:
                <ul>
                    <li><em>Value constraints</em> - </li>
                    <li><em>Mandatory</em> - </li>
                    <li><em>Auto-created</em></li>
                    <li><em>Default value</em></li>
                </ul>
            </p>
            <section>
                <h4 id="property-value-type">Value Type</h4>
                <p>
                    The following <i>standard</i> types are available, although a <a>repository</a>
                    may choose to support additional <a>types</a>:
                    <table class="simple">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Datatype <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>string</td>
                                <td><code>type:string</code></td>
                                <td>A sequence of characters encoded as UTF-8</td>
                            </tr>
                            <tr>
                                <td>boolean</td>
                                <td><code>type:boolean</code></td>
                                <td>The value of <code>true</code> or <code>false</code></td>
                            </tr>
                            <tr>
                                <td>long</td>
                                <td><code>type:long</code></td>
                                <td>An integer with a minimum value of -2<sup>63</sup> and a maximum value of
                                    2^<sup>63-1</sup>.
                                </td>
                            </tr>
                            <tr>
                                <td>double</td>
                                <td><code>type:double</code></td>
                                <td>A double-precision 64-bit IEEE 754 floating point.
                                </td>
                            </tr>
                            <tr>
                                <td>decimal</td>
                                <td><code>type:decimal</code></td>
                                <td>...</td>
                            </tr>
                            <tr>
                                <td>date</td>
                                <td><code>type:date</code></td>
                                <td>An [[ISO8601]] date</td>
                            </tr>
                            <tr>
                                <td>weakreference</td>
                                <td><code>type:weakreference</code></td>
                                <td>An identifer to a referenceable node <i>without</i> enforced referential integrity.
                                </td>
                            </tr>
                            <tr>
                                <td>reference</td>
                                <td><code>type:reference</code></td>
                                <td>An identifer to a referenceable node <i>with</i> enforced referential integrity.
                                </td>
                            </tr>
                            <tr>
                                <td>uri</td>
                                <td><code>type:uri</code></td>
                                <td>A sequence of characters that conform to [[RFC3987]]</td>
                            </tr>
                            <tr>
                                <td>path</td>
                                <td><code>type:path</code></td>
                                <td>A <a>path</a> in either <a>absolute</a> or <a>relative</a> form represented in its
                                    lexical (string) form</td>
                            </tr>
                        </tbody>
                    </table>
                </p>
            </section>
            <section>
                <h4 id="single-multi-value-properties">Single & Multi-Valued Property</h4>
                <p>

                </p>
            </section>
            <section>
                <h4 id="mandatory-properties">Mandatory Properties</h4>
                <p>
                    A property may be marked as <em>mandatory</em>. If the property is single-valued then a
                    value must be present for that property and there is no <code>null</code> value. If the
                    property is multi-valued it may have zero or more values.
                </p>
            </section>
            <section>
                <h4>Value Ordering</h4>
                <p>
                    Multi-value properties can be declared as <em>arrays</em> or <em>sets</em>.
                </p>
            </section>
            <section>
                <h3>Values Constraints</h3>
                <p>
                    Value constraints limit the range of possible values that a property can hold. They are
                    an extension to the restrictions enforced by the value type (see [[[#property-value-type]]])
                    and allow for further modelling of the metadata domain.
                </p>
                <section>
                    <h4><code>type:string</code> Constraints</h4>
                    <p>Constraints on <code>type:string</code> are expressed as <em>regular expressions</em>. The
                        exact implementation of regular expression used is implementation specific.</p>
                </section>
                <section>
                    <h4>Numeric Type Constraints</h4>
                    <p>Types <code>type:long</code>, <code>type:decimal</code>, <code>type:double</code> and
                        <code>type:date</code> may be subject to <em>numerical</em> constraints limiting
                        the range of possible values available. This is achieved using a comma separated
                        pair including an <em>upper</em> and <em>lower</em> bound in the form enclosed in either
                        a square bracket <code>[]</code> or parenthesis <code>()</code>. The square brackets
                        <code>[]</code> indicate inclusivity and the parenthesis <code>()</code> indicate
                        exclusivity.
                    </p>
                    <p>
                        Some examples:
                        <ul>
                            <li><code>[0,100]</code> - an <em>inclusive</em> range permitting the integers
                                <code>0</code> to <code>100</code></li>
                            <li><code>(0,100)</code> - an <em>exclusive</em> range permitting the integers
                                <code>1</code> to <code>99</code></li>
                            <li><code>[1649627836,]</code> - this indicates any value <code>1649627836</code>
                                or greater. If this was a date then it would represent any date on or after
                                <em>Sunday, 10 April 2022 22:57:16 GMT+01:00</em>.</li>
                            <li><code>[200,500)</code> - an <em>inclusive floor</em> and <em>exclusive ceiling</em>
                                permitting integers in the range <code>200</code> to <code>499</code></li>
                            <li><code>[,500)</code> - any integer up to <code>499</code></li>
                        </ul>
                    </p>
                </section>
                <section>
                    <h4><code>type:path</code> Constraints</h4>
                    <p>Path constraints can either prescribe a specific allowed path or an allowed ancestor if
                        terminating in <code>/*</code>. These constraints allow the model to enforce that a
                        property can only refer to specific paths or subpaths.
                    </p>
                    <p>
                        Some examples:
                        <ul>
                            <li><code>/path/to/node</code> - the path must be equal to this value</li>
                            <li><code>/path/to/ancestor/*</code> - the path must start with
                                <code>/path/to/ancestor</code></li>
                        </ul>
                    </p>
                </section>

            </section>
            <section>
                <h3 id="default-values-property">Default Values</h3>
                <p>
                    The default value of a property is the value assigned to a property if it is auto-created
                    (see [[[#auto-created-property]]]). This may be a single value or multiple values depending
                    on the [[[#single-multi-value-properties]]]. The default value must have the same value type
                    as the property it is defined on.
                </p>
            </section>
            <section>
                <h3 id="auto-created-property">Auto-created Values</h3>
                <p>
                    A property may be declared auto-created, meaning that it is automatically created upon creation of
                    its parent <a>node</a> or the moment that the property becomes part of a node&quot;s type. If no
                    value is supplied during <a>node</a> creation then the default value is used (see
                    [[[#default-values-property]]]). Auto-created values are especially useful when
                    adding mandatory properties to node types.
                </p>
                <p>
                    <div class="note">
                        Properties may be auto-created if the node implicitly acquires the property from one
                        of its <a>supertypes</a> or if a <a>mixin</a> type is added to a node type. For example,
                        adding <code>mix:created</code> implies the addition of <code>hmf:created</code> and
                        <code>hmf:createdBy</code> which should be
                    </div>
                </p>
            </section>
            <section>
                <h3 id="protected-property">Protected Properties</h3>
                <p>
                    <a>Protected</a> properties are properties that are managed by the implementation and
                    cannot be modified by clients. Protected properties are read-only by clients and
                    read-write for implementations.
                </p>
            </section>
            <section>
                <h4>Property Type Documentation</h4>
                <p>
                    Properties may optionally carry narrative documentation about its role of purpose to support
                    auto-generated documentation or to drive a user interface.
                </p>
            </section>
        </section>
        <section>
            <h3 id="node-types">Node Types</h3>
            <section>
                <h4>Node Primary Type</h4>
                <p>
                    Every <a>node</a> has a single declared primary type. Nodes have an <em>is-a</em> relationship
                    with the primary type. The primary type of a node typically defines the core characteristics of the
                    node in the domain model. This is in contrast to mixin nodes which add additional and supplimentary
                    functionality or metadata.
                </p>
                <p>Given that primary types may inherit from one another, a node can be said to have multiple types
                    or formally, multiple <a>supertypes</a>. Implementations should provide the means to acquire all
                    supertypes of a node.
                </p>
                <p>
                    The default primary type of a node is <code>hmf:base</code> (see [[[#builtin-primary-types]]]).
                </p>
            </section>
            <section>
                <h4>Mixin Types</h4>
                <p>
                    A <a>node</a> may have zero or more <a>mixin types</a>. Mixin types provide a way to compose
                    functionality or key metadata (such as standardized metadata, see [[[#builtin-mixins]]])
                    on a node. They are used to mark nodes as eligible for some model or repository feature such as
                    <code>mix:annotated</code> (see [[[#annotations]]]) and <code>mix:versionable</code> (see
                    [[[#versioning]]]).
                </p>
                <p>
                    Mixin types may not be used as a primary type of a node, however they can be used as supertypes
                    of primary types. Only mixin types may be supertypes of mixin types.
                </p>
            </section>
            <section>
                <h4 id="node-type-inheritance">Node Type Inheritance</h4>
                <p>
                    Both primary types and mixin types can take advantage of inheritance.
                </p>

            </section>
            <section>
                <h4>Updating the Primary Type</h4>
                <p>
                    The <a>primary type</a> of a node may be modified after node creation. This is a key capability
                    of HMF since it allows for progressive typing during the lifecycle of a metadata <a>tree</a>.
                    The primary type of a node may only be changed if all mandatory <a>items</a> are already present
                    on that node.
                </p>
            </section>
        </section>
        <section>
            <h3 id="node-type">Node Definition</h3>
            <p>

            </p>

            <section>
                <h4 id="">Child Constraints</h4>
                <p>

                </p>
            </section>
            <section>
                <h4 id="child-constraints">Child Constraints</h4>
                <p>

                </p>
            </section>
            <section>
                <h4>Type Composition</h4>
                <p>
                    Mixin Types
                </p>
            </section>
            <section>
                <h4>Abstract Types</h4>
                <p>

                </p>
            </section>
            <section>
                <h4>Type Inheritance</h4>
                <p>

                </p>
            </section>
            <section>
                <h3 id="auto-created-node">Auto-created Nodes</h3>
                <p>

                </p>
            </section>
            <section>
                <h4>Node Type Documentation</h4>
                <p>
                    A <code>hmf:documentation</code> property may be added to a node type definition containing a
                    <code>type:string</code> value.
                </p>
            </section>
        </section>
        <section>
            <h3>Builtin Types</h3>
            <section>
                <h4 id="builtin-primary-types">Builtin Primary Types</h4>
                <p>

                </p>
                <table class="simple">
                    <thead>
                        <tr>
                            <th>Type <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>hmf:base</code></td>
                            <td>
                                This is the base type of all primary node types and therefore all nodes in a
                                HMF model. It exposes the mandatory property <code>hmf:primaryType</code>
                                and the optional property <code>hmf:mixinTypes</code>.
                            </td>
                        </tr>
                    </tbody>
                </table>
                <h4 id="builtin-mixins">Builtin Mixin Types</h4>
                <table class="simple">
                    <thead>
                        <tr>
                            <th>Type <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>mix:created</code></td>
                            <td>
                                Used to add standardized information about the creation of the node via the
                                properties
                                <code>hmf:created</code> (providing the timestamp that the node was created) and
                                <code>hmf:createdBy</code> (providing the principal that created the node).
                                In cases where the <a>mixin</a> is applied to an already created node, these
                                properties
                                must be auto-created with values as-determined by the implementation.
                            </td>
                        </tr>
                        <tr>
                            <td><code>mix:modified</code></td>
                            <td>
                                Used to add standardized information about the modification of the node via the
                                properties
                                <code>hmf:modified</code> (providing the timestamp that the node was modified) and
                                <code>hmf:modified</code> (providing the principal that modified the node).
                                In cases where the <a>mixin</a> is applied to an already created node, these
                                properties
                                must be auto-created.
                            </td>
                        </tr>
                        <tr>
                            <td><code>mix:versionable</code></td>
                            <td>
                                Indicates that the <a>node</a> is subject to versioning. See [[[#versioning]]].
                            </td>
                        </tr>
                        <tr>
                            <td><code>mix:annotated</code></td>
                            <td>
                                Indicates that the <a>node</a> carries annotations. See [[[#annotations]]]
                            </td>
                        </tr>
                    </tbody>
                </table>
            </section>
        </section>

    </section>
    <section>
        <h2 id="versioning">Versioning</h2>
        <section class="informative">
            <h3>Introduction</h3>
            <p>
                Versioning is enabled via <a>version storage</a>; a separate area of the metadata
                model dedicating to storing and managing historical snapshots of <a>nodes</a> and their
                <a>subtrees</a>. Versionable <a>nodes</a> (i.e. those with the type <code>mix:versionable</code>)
                hold references to the historical <a>node</a> snapshots so that they can be discovered
                and acted upon. A <a>node</a> that does not carry the <code>mix:versionable</code> type
                cannot be versioned.
            </p>
            <p>
                A <a>versionable</a> <a>node</a> can be <em>checked-in</em> and <em>checked-out</em>.
                Checking-in creates a <em>new version</em> of the node state along with its versionable
                subtree (see [[[#verisonable-subtree]]]). This new version is appended to the version
                history (see [[[#version-history]]]) held within <a>version storage</a> where it can be
                later accessed.
            </p>
            <div class="illustration">
                <p><img src="version-history-simple.png" alt="Simple Versioning Representation" width="700" /></p>
                <p class="caption">A <a>node</a> <code>N</code> with versionable child <code>C</code>
                    along with its version history. Version <code>N<sub>V2</sub></code> is expanded in the
                    illustration showing that the versionable child <code>C<sub>V2</sub></code> is also
                    persisted.
                </p>
            </div>
            <p>
                Checking-in also makes the node <em>read-only</em>.
            </p>
            <p>
                One of the versions in the version history is marked as the <a>base version</a>. The base
                version is the version against which modifications to a checked-out node are made. That is,
                any changes between the base version and the checked-out node are considered as <a>
                    versionable changes</a>. When node
            </p>
        </section>
        <h3>Versionable Nodes</h3>
        <h3>Checked-in &amp; Checked-out State</h3>
        <h3>Version Labels</h3>
        <h3 id="versionable-subtree">Versionable Subtree</h3>
        <h3>On-Parent Version</h3>
        <h3>Referencing a Version</h3>
        <h3>Version Tags</h3>
        <h3 id="version-history">Version History</h3>
    </section>
    <section>

        <h2 id="repository">Repository</h2>
        <section class="informative">
            <h3>Introduction</h3>
            <p>
                A <a>repository</a> provides container services to <abbr
                    title="Hierarchical Metadata Framework">HMF</abbr> metadata.
            </p>
        </section>

        <section>
            <h3>Repository Root</h3>
            <p>

            </p>
        </section>

        <section>
            <h3>Repository Node</h3>
            <p>

            </p>
        </section>

        <section>
            <h3 id="move-copy">Move, Copy and Delete Semantics</h3>
            <p>

            </p>
        </section>

        <section>
            <h3 id="namespace-registry">Namespace Registry</h3>
            <p>
                The repository provides access to the <a>namespace registry</a> containing a mapping of
                <a>prefixes</a> to their corresponding <a>namespace IRI</a>.
            </p>
            <section>
                <h4>Default Mappings</h4>
                <p>
                    Repositories contain at least following mappings:
                </p>
                <table class="simple">
                    <thead>
                        <tr>
                            <th>Namespace Prefix</th>
                            <th>Namespace <abbr title="Internationalized Resource Identifier">IRI</abbr></th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>hmf</td>
                            <td>http://hmf.org/ns/hmf/1.0</td>
                            <td>Reserved for <a>items</a> defined within in core <abbr
                                    title="Hierarchical Metadata Framework">HMF</abbr> <a>types</a>
                            </td>
                        </tr>
                    </tbody>
                    <tbody>
                        <tr>
                            <td>mix</td>
                            <td>http://hmf.org/ns/mix/1.0</td>
                            <td>Reserved for the <a>names</a> of built-in <a>mixin</a> <a>node</a> <a>types</a>.
                            </td>
                        </tr>
                    </tbody>
                    <tbody>
                        <tr>
                            <td><em>the empty string</em></td>
                            <td><em>the empty string</em></td>
                            <td>The default namespace is the <em><a>empty namespace</a></em>.
                            </td>
                        </tr>
                    </tbody>
                </table>

            </section>

            <section>
                <h4 id="empty-namespace">Empty Namespace</h4>
                <p>
                    The <a>empty namespace</a> is a permanent and immutable member of the <a>namespace registry</a>
                    which can be used for default data or when <a>namespaces</a> are not required, such as for
                    trivial
                    or single domain metadata storage applications.
                </p>
            </section>

        </section>
        <section class="informative">
            <h2>Indexing</h2>

        </section>
        <section class="informative">
            <h2>Internationalization</h2>
            <p>Storing internationlized strings... </p>
        </section>
        <section class="informative">
            <h2>Relationship to RDF</h2>

        </section>

    </section>


</body>

</html>